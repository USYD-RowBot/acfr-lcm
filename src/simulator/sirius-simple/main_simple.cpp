// sirius AUV simulator


#include <iostream>
#include <fstream>
#include <lcm/lcm-cpp.hpp>
#include <signal.h>
#include <boost/numeric/odeint.hpp>
#include <small/Pose3D.hh>
#include <bot_param/param_client.h>
#include "acfr-common/auv_map_projection.hpp"
#include "perls-lcmtypes++/perllcm/heartbeat_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_acfr_nav_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_sirius_motor_command_t.hpp"
#include "perls-common/timestamp.h"
#include "perls-lcmtypes++/senlcm/tcm_t.hpp"
#include "perls-lcmtypes++/senlcm/ysi_t.hpp"
#include "perls-lcmtypes++/senlcm/gpsd3_t.hpp"
#include "perls-lcmtypes++/senlcm/rdi_pd5_t.hpp"
#include "perls-lcmtypes++/senlcm/IMU_t.hpp"

#include "simulator-common/vehicleSimBase.hpp"

using namespace std;
using namespace boost::numeric::odeint;
using namespace acfrlcm;
using namespace perllcm;
using namespace senlcm;
using namespace libplankton;
using namespace vehicleSimSimple;

// generated by matlab
#include "vehicle_params_small.h"

#define SIRIUS_DIAM 0.3 
#define SIRIUS_RADIUS (0.5*SIRIUS_DIAM)
#define SIRIUS_LENGTH 2.5 
#define SIRIUS_LAT_OFFSET 0.5
#define SIRIUS_VERT_DISTANCE 2 
#define SIRIUS_LAT_DISTANCE 1.8 
#define SIRIUS_MASS 120 
#define SIRIUS_INERTIA ((0.0833*SIRIUS_MASS*SIRIUS_LENGTH*SIRIUS_LENGTH) + (0.25*SIRIUS_MASS*SIRIUS_DIAM*SIRIUS_DIAM))

class SiriusVehicleSim : public VehicleSimBase
{
public:
    SiriusVehicleSim();
    virtual ~SiriusVehicleSim() = default;

protected:
    virtual void updateState( const state_type &x , state_type &dxdt , const double /* t */);

    virtual void publishSensorData();

    virtual void subscribeLCMChannels();
    
    void on_motor_command(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const auv_sirius_motor_command_t *mc);

private:
    auv_sirius_motor_command_t motor_cmd_in;
};

SiriusVehicleSim::SiriusVehicleSim()
{
}

void SiriusVehicleSim::updateState( const state_type &x , state_type &dxdt , const double )
{
    double Xa, Ya, Za;
    double u, v, w, p, q, r;
    double phi, theta, psi;
    Xa = x[XNDX];
    Ya = x[YNDX];
    Za = x[ZNDX];
    phi = x[ROLLNDX];
    theta = x[PITCHNDX];
    psi = x[HDGNDX];
    u = x[XDOTNDX];
    v = x[YDOTNDX];
    w = x[ZDOTNDX];
    p = x[ROLLDOTNDX];
    q = x[PITCHDOTNDX];
    r = x[HDGDOTNDX];
    
    auv_sirius_motor_command_t in = this->motor_cmd_in;

    // adjustments for a constant water current (or wind)

    SMALL::Rotation3D Cbn;
    Cbn.setRollPitchYawRad(phi, theta, psi);

    // current in the navigation frame
    SMALL::Vector3D vc_n;
    vc_n = CURRENT,0,0;
    // current in the body frame
    SMALL::Vector3D vc_b;
    vc_b = (Cbn.i() * vc_n);

    // vehicle velocity in the current
    u = u - vc_b(1);
    v = v - vc_b(2);
    w = w - vc_b(3);

    // make heading 0 to 2pi
    while(psi < 0)
        psi += 2 * M_PI;
    while(psi > (2 * M_PI))
        psi -= 2 * M_PI;

    // Where we are at, ie the auv pose
    SMALL::Pose3D auvPose;
    auvPose.setPosition(Xa, Ya, Za);
    auvPose.setRollPitchYawRad(phi, theta, psi);

    // Prop force calculations
    double prop_alpha = 0.02290; //0.01; // advance ratio
    double prop_diameter = 0.5;
    double rho = 1030;              // Water density
    double J0 = 0; // open water advance coefficient
    double Kt = 0; // propeller thrust coefficient
    double Kq = 0; // properler torque coefficient
    
    double alpha1 = 0.5;
    double alpha2 = -4.0/11.0;
    double alpha3 = (0.45 - alpha1)/(-0.2);
    double alpha4 = 0.45 -(-0.2* (0.95-0.45) / (-0.5-(-0.2)) );
    double alpha5 = (0.95-0.45) / (-0.5-(-0.2));

    // these need to be determined
    // but relate to the torque from the rear thruster
    // not sure but it may result in a torque not around
    // the x-axis of the vehicle
    double beta1 = 0.0;
    double beta2 = -0.0;

    double omega = 0.1;
   
    // **************************
    // * Prop force from the vert
    // *************************
    //
    // propeller revolutions per second (rps)
    // converting desired rpm to rps
    double n_vert = in.vertical/60;
    
    // limit the max rpm to 1500 = 25 rps
    if(fabs(n_vert) > 25)
        n_vert = n_vert / fabs(n_vert) * 25;
    
    // advance velocity as per Fossen eq 4.6
    double Va_vert = (1 - omega) * w;
    
    if(fabs(n_vert) > 1e-3)
        J0 = Va_vert / (n_vert * prop_diameter);      // as per Fossen eq 6.107

    if (J0 > 0)
    {
        Kt = alpha1 + alpha2 * J0;   // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else if (J0 > -0.2)
    {
        Kt = alpha1 + alpha3 * J0;			// Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else
    {
        Kt = alpha4 + alpha5 * J0; // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }

    double vert_force;//, prop_torque;
    vert_force = rho * pow(prop_diameter,4) * Kt * fabs(n_vert) * n_vert;     // As per Fossen eq 4.2
    //prop_torque = rho * pow(prop_diameter,5) * Kq * fabs(n) * n; // Fossen 6.113
    //    cout << "n = " << n << " Va = " << Va << " J0 = " << J0 << " Kt = " << Kt << " F = " << prop_force << endl;
    if(vert_force !=  vert_force)
    {
        cerr << "Vert force error" << endl;
        vert_force = 0;
    }

    // **************************
    // * Prop force from the port 
    // *************************
    //
    // propeller revolutions per second (rps)
    // converting desired rpm to rps
    double n_port = in.port/60;
    
    // limit the max rpm to 1500 = 25 rps
    if(fabs(n_port) > 25)
        n_port = n_port / fabs(n_port) * 25;
    
    // advance velocity as per Fossen eq 4.6
    double Va_port = (1 - omega) * u;
    
    if(fabs(n_port) > 1e-3)
        J0 = Va_port / (n_port * prop_diameter);      // as per Fossen eq 6.107

    if (J0 > 0)
    {
        Kt = alpha1 + alpha2 * J0;   // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else if (J0 > -0.2)
    {
        Kt = alpha1 + alpha3 * J0;			// Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else
    {
        Kt = alpha4 + alpha5 * J0; // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }

    double port_force;//, prop_torque;
    port_force = rho * pow(prop_diameter,4) * Kt * fabs(n_port) * n_port;     // As per Fossen eq 4.2
    //prop_torque = rho * pow(prop_diameter,5) * Kq * fabs(n) * n; // Fossen 6.113
    //    cout << "n = " << n << " Va = " << Va << " J0 = " << J0 << " Kt = " << Kt << " F = " << prop_force << endl;
    if(port_force !=  port_force)
    {
        cerr << "Port force error" << endl;
        port_force = 0;
    }
    

   
    // **************************
    // * Prop force from the stbd
    // *************************
    //
    // propeller revolutions per second (rps)
    // converting desired rpm to rps
    double n_stbd = in.starboard/60;
    
    // limit the max rpm to 1500 = 25 rps
    if(fabs(n_stbd) > 25)
        n_stbd = n_stbd / fabs(n_stbd) * 25;
    
    // advance velocity as per Fossen eq 4.6
    double Va_stbd = (1 - omega) * u;
    
    if(fabs(n_stbd) > 1e-3)
        J0 = Va_stbd / (n_stbd * prop_diameter);      // as per Fossen eq 6.107

    if (J0 > 0)
    {
        Kt = alpha1 + alpha2 * J0;   // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else if (J0 > -0.2)
    {
        Kt = alpha1 + alpha3 * J0;			// Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else
    {
        Kt = alpha4 + alpha5 * J0; // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }

    double stbd_force;//, prop_torque;
    stbd_force = rho * pow(prop_diameter,4) * Kt * fabs(n_stbd) * n_stbd;     // As per Fossen eq 4.2
    //prop_torque = rho * pow(prop_diameter,5) * Kq * fabs(n) * n; // Fossen 6.113
    //    cout << "n = " << n << " Va = " << Va << " J0 = " << J0 << " Kt = " << Kt << " F = " << prop_force << endl;
    if(stbd_force !=  stbd_force)
    {
        cerr << "Stbd force error" << endl;
        stbd_force = 0;
    }
    

  
    // ***********
    // Drag forces
    // ***********
    double Cd_surge = 3; //0.82; // modelled on a long cylinder
    double A_surge = M_PI * pow(SIRIUS_RADIUS,2); // submerged
    double Cd_across = 5; //1.17; // modelled on a long cylinder
    double A_across = (SIRIUS_DIAM * SIRIUS_LENGTH);
    
    double Fd_surge = 0.5 * rho * A_surge * Cd_surge * fabs(u) * u ;
    double Fd_sway = 0.5 * rho * A_across * Cd_across * fabs(v) * v;
    double Fd_vert = 0.5 * rho * A_across * Cd_across * fabs(w) * w;
   
    // *************************
    // Gravity and Buoyant Force
    // *************************
    double F_g = SIRIUS_MASS*9.81;
    double A_sub = M_PI * pow(SIRIUS_RADIUS,2);
    double A_breach = 0;
    // Assume that depth is measured at the middle of the vehicle
    if (x[ZNDX] < SIRIUS_RADIUS)
    {
        A_breach = pow(SIRIUS_RADIUS,2) * acos(x[ZNDX]/(SIRIUS_RADIUS)) - x[ZNDX]*sqrt(pow(SIRIUS_RADIUS,2)-pow(x[ZNDX],2));
        A_sub -= A_breach;
    }
    double F_buoy = 0.66 * rho * A_sub * SIRIUS_LENGTH * 9.81; // model the buoyancy to be slightly higher than the force of gravity when fully submerged


    //cout << " F_buoy: " << F_buoy << " A_breach: " << A_breach << " A_sub: " << A_sub << endl;

    // *************************
    // External applied forces
    // *************************
    double F_surge, F_sway, F_vert;
    F_surge = port_force + stbd_force - Fd_surge;
    F_sway = 0;
    F_vert = vert_force - Fd_vert  + F_g - F_buoy;

    // *************************
    // Applied torques 
    // *************************
    // model the vehicle as a long cylinder spinning in a fluid
    // treat the cylinder as a series of disks of the diameter of the vehicle 
    // and of thickness dR.  The velocity through water of each disk is related to the
    // angular velocity w by the distance to the centre R.  
    //  dF_drag = 0.5 * Cd * rho * (Rw)^2 * Diam * dR (where R is the distance from the centre of the vehicle)
    //
    // Integrating the drag along the length from the centre, we have:
    //  T_drag = 1/3 * Cd * rho * Diam * w^2 * (L/2)^3
    //
    double Td_hdg = 0.333 * Cd_across * rho *  (SIRIUS_DIAM) * fabs(r) * r * pow(0.5*SIRIUS_LENGTH,3); 
    //double Td_hdg = 100000 * fabs(r) * r;
    double T_hdg = (port_force * SIRIUS_LAT_OFFSET) - (stbd_force * SIRIUS_LAT_OFFSET) - Td_hdg;
   
    double Td_pitch = 0.333 * Cd_across * rho *  (SIRIUS_DIAM) * fabs(q) * q * pow(0.5*SIRIUS_LENGTH,3); 
    //double Td_pitch = 100000 * fabs(q) * q; 

    double d_buoy_centre = 0.5; // assume the buoyancy and gravity each act centered at around 50cm from the centre of the vehicle
    double T_buoy = F_buoy * d_buoy_centre * sin(x[PITCHNDX]);
    double T_g = F_g * d_buoy_centre * sin(x[PITCHNDX]);

    double T_pitch = (- Td_pitch - T_buoy - T_g);

    // update the rates of change of the system states
    dxdt[XNDX] = u*cos(psi);
    dxdt[YNDX] = u*sin(psi);
    dxdt[ZNDX] = w;
    dxdt[ROLLNDX] = p;
    dxdt[PITCHNDX] = q;
    dxdt[HDGNDX] = r;
    dxdt[XDOTNDX] = F_surge/SIRIUS_MASS;
    dxdt[YDOTNDX] = F_sway/SIRIUS_MASS;
    dxdt[ZDOTNDX] = F_vert/SIRIUS_MASS;
    dxdt[ROLLDOTNDX] = 0;
    dxdt[PITCHDOTNDX] = T_pitch / SIRIUS_INERTIA;  // FIXME: Need to account for pitch here
    dxdt[HDGDOTNDX] = T_hdg / SIRIUS_INERTIA;

    static int loopCount = 0;

    if (loopCount++ > 100)
    {
        cout << "x: " << x[XNDX] << " y: " << x[YNDX] << " z: " << x[ZNDX] << " roll: " << x[ROLLNDX] << " pitch: " << x[PITCHNDX] << " hdg: " << x[HDGNDX] << endl;
        cout << "u: " << u << " v: " << v << " w: " << w << " p: " << p << " q: " << q << " r: " << r << endl;
        cout << "Fsurge: " << F_surge << " F_sway:" << F_sway << " F_vert:" << F_vert << " vert_force: " << vert_force << " port_force: " << port_force << " stbd_force: " << stbd_force << endl;
        cout << " Fd_vert: " << Fd_vert << " F_g: " << F_g << " F_buoy: " << F_buoy << endl;
        cout << "T_hdg: " << T_hdg << " Td_hdg: " << Td_hdg << endl;
        cout << "T_pitch: " << T_pitch << " Td_pitch: " << Td_pitch << " T_buoy: " << T_buoy << " T_g: " << T_g <<  endl;
        cout << "dx:" << dxdt[XNDX] << " dy:" << dxdt[YNDX] << " dz: " << dxdt[ZNDX] << " droll: " << dxdt[ROLLNDX] << " dpitch: " << dxdt[PITCHNDX] << " dhdg: " << dxdt[HDGNDX] << endl;
        cout << "dxdot: " << dxdt[XDOTNDX] << " dydot: " << dxdt[YDOTNDX] << " dzdot: " << dxdt[ZDOTNDX] << " drolldot: " << dxdt[ROLLDOTNDX] << " dpitchdot: " << dxdt[PITCHDOTNDX] <<  " dhdgdot:" << dxdt[HDGDOTNDX] << endl;
        loopCount = 0;
    }
}

// motor command callback
void SiriusVehicleSim::on_motor_command(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const auv_sirius_motor_command_t *mc) 
{
    motor_cmd_in = *mc;
}


void SiriusVehicleSim::publishSensorData()
{
    //publishACFRNav();
    //publishIMU();
    publishTCM();
    publishParosci();
    publishGPS();
    publishDVL();
}

void SiriusVehicleSim::subscribeLCMChannels()
{
    lcm.subscribe(vehicle_name+".SIRIUS_MOTOR", &SiriusVehicleSim::on_motor_command, this);
}

void print_help (int exval, char **argv)
{                                                                               
    printf("Usage:%s [-h] [-n VEHICLE_NAME]\n\n", argv[0]);                     
    
    printf("  -h                               print this help and exit\n");    
    printf("  -n VEHICLE_NAME                  set the vehicle_name\n");        
    exit (exval);                                                               
}                                                                               
                                                                                
void                                                                            
parse_args (int argc, char **argv, vehicleSimSimple::VehicleSimBase &vehicleSim)                                              
{                                                                            
    int opt;                                                                    
                                                                                
    while ((opt = getopt (argc, argv, "hn:")) != -1)                            
    {                                                                           
        switch(opt)                                                             
        {                                                                       
            case 'h':                                                               
                print_help (0, argv);                                               
                break;                                                              
            case 'n':                                                               
                vehicleSim.setVehicleName((char*)optarg);                                       
                break;                                                              
         }                                                                      
    }                                                                           
}
        
int main_exit;
void signal_handler(int sig)
{
    main_exit = 1;
}

int main(int argc, char **argv)
{
    SiriusVehicleSim vehicleSim;

    parse_args(argc, argv, vehicleSim);

    // install the signal handler
    main_exit = 0;
    signal(SIGINT, signal_handler);

    cout << "Starting sim..." << endl;
    vehicleSim.run();

    return 0;
}



