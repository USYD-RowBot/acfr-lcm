// Iver simulator


#include <iostream>
#include <fstream>
#include <lcm/lcm-cpp.hpp>
#include <signal.h>
#include <libplankton/auv_geometry.hpp>
#include <boost/numeric/odeint.hpp>
#include "perls-lcmtypes++/perllcm/heartbeat_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_acfr_nav_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_iver_motor_command_t.hpp"
#include "perls-common/timestamp.h"

using namespace libplankton;
using namespace std;
using namespace boost::numeric::odeint;
using namespace acfrlcm;
using namespace perllcm;

// generated by matlab
#include "vehicle_params.h"

#define WATER_DEPTH 30

typedef boost::numeric::ublas::vector< double > state_type;

// Rotations
Vector transform_to_earth(Vector point, double roll, double pitch, double yaw)
{
    
    Matrix rot(rot_mat_back(roll, pitch, yaw));

    Matrix rot6(6,6);
    rot6(0,0) = rot(0,0);
    rot6(0,1) = rot(0,1);
    rot6(0,2) = rot(0,2);
    rot6(1,0) = rot(1,0);
    rot6(1,1) = rot(1,1);
    rot6(1,2) = rot(1,2);
    rot6(2,0) = rot(2,0);
    rot6(2,1) = rot(2,1);
    rot6(2,2) = rot(2,2);
    
    
    rot6(3,3) = 1;
    rot6(4,3) = 0;
    rot6(5,3) = 0;
    rot6(3,4) = sin(roll)*tan(pitch);
    rot6(4,4) = cos(roll);
    rot6(5,4) = sin(roll)/cos(pitch);
    rot6(3,5) = cos(roll)*tan(pitch);
    rot6(4,5) = -sin(roll);
    rot6(5,5) = cos(roll)/cos(pitch);
    
    Vector new_point(prod(rot6, point));
    
    return new_point;
}
        
Vector transform_to_body(Vector point, double roll, double pitch, double yaw)
{
    
    Matrix rot(rot_mat_forward(roll, pitch, yaw));
    Vector new_point(prod(rot, point));
    return new_point;
}

// state vectors
state_type state(12);
euler<state_type> stepper;

// main set of equations

ofstream fp;


// the state vector is X Y Z r p h vx vy vz p q r
// the control vector is RPM prop_torque rudder, plane
Vector in(4);

void auv( const state_type &x , state_type &dxdt , const double /* t */ )
{
    double X, Y, Z, K, M, N;
    double u, v, w, p, q, r;
    double phi, theta, psi;
    X = x[0];
    Y = x[1];
    Z = x[2];
    
    u = x[6];
    v = x[7];
    w = x[8];
    p = x[9];
    q = x[10];
    r = x[11];
    
    Vector nu(6);
    nu(0) = u;
    nu(1) = v;
    nu(2) = w;
    nu(3) = p;
    nu(4) = q;
    nu(5) = r;
    
    phi = x[3];
    theta = x[4];
    psi = x[5];
    
    // Hydro static and gravitational forces
    
    Vector fG(3);
    fG(0) = 0;
    fG(1) = 0;
    fG(2) = W;
    
    Vector fG_body = transform_to_body(fG, phi, theta, psi);
    
    Vector fB(3);
    fB(0) = 0;
    fB(1) = 0;
    
    if(Z > 0)
        fB(2) = B;
    else
        fB(2) = 0;
        
    Vector fB_body = transform_to_body(fB, phi, theta, psi);
    
//    cout << fG_body << endl;
//    cout << fB_body << endl;
    
    Vector rG(3);
    rG(0) = xG;
    rG(1) = yG;
    rG(2) = zG;

    Vector rB(3);
    rB(0) = 0;
    rB(1) = 0;
    rB(2) = 0;


    Vector forces_HS(6);
    Vector forces_HS1 = (fG_body - fB_body);
    Vector forces_HS2 = (cross_prod(rG, fG_body) - cross_prod(rB, fB_body));
    
    forces_HS(0) = forces_HS1(0);
    forces_HS(1) = forces_HS1(1);
    forces_HS(2) = forces_HS1(2);
    forces_HS(3) = forces_HS2(0);
    forces_HS(4) = forces_HS2(1);
    forces_HS(5) = forces_HS2(2);


    double prop_alpha = 0.02290; //0.01;
    double prop_diameter = 0.085;
    // water density
    double rho = 1030;
    // open water advance coefficient
    double J0 = 0;
    // propeller torque coefficient
    double Kt = 0;
    

//    if((abs(u) > 0.01) && (abs(in(0)) > 0))
//        J = u / (2 * prop_alpha * in(0) * prop_diameter);
//    else// if(abs(in(0)) < 0.1)
//        J = 0.8;
    if(in(0) != in(0))
    {
        in(0) = 0;
        cerr << "In 0 NaN" << endl;
    }
    
    // propeller revolutions per second (rps)
    // converting desired rpm to rps
    double n = in(0)/60;
    
    // advance velocity as per Fossen eq 4.6
    double omega = 0.1;
    double Va = (1 - omega) * u;
    
    if(fabs(n) > 1e-3)
        // as per Fossen eq 6.107
        J0 = Va / (n * prop_diameter);
//    else
//        J = 0;

    
    double alpha1 = 0.4;
    double alpha2 = -4.0/11.0;
    Kt = alpha1 + alpha2 * J0;   // Fossen eq 6.113
        
    double prop_force;
    //if(fabs(Va) < 0.1)
    //    prop_force = 0;
    //else        
//        prop_force = rho * pow((prop_alpha * in(0)),2) * pow(prop_diameter,4) * Kt;
          // As per Fossen eq 4.2
    prop_force = rho * pow(prop_diameter,4) * Kt * fabs(n) * n;
          

    
    if(prop_force !=  prop_force)
    {
        cerr << "Prop force error" << endl;
        prop_force = 0;
    }
    
//    cout << in(0) << ", " << prop_force << "  ,  " << Kt << " , " << J << endl;
    
    // set the fins to zero is we aren't moving as the model doesn't behave
    double rudder, plane;
    if(fabs(u) < 0.1)
        rudder = 0;
    else
        rudder = in(2);

    if(fabs(u) < 0.1)
        plane = 0;
    else
        plane = in(3);

    
    // Hydrodynamic Forces and Moments
    X = Xuu * u * fabs(u) + (Xwq - m) * w * q 
        + (Xqq + m * xG) * pow(q, 2) + (Xvr + m) * v * r 
        + (Xrr + m * xG) * pow(r, 2) - m * yG * p * q 	
        - m * zG * p * r + prop_force;
        
    Y = Yvv * v * fabs(v) + Yrr * r * fabs(r)
        + m * yG * pow(r, 2) + (Yur - m) * u * r
        + (Ywp + m) * w * p + (Ypq - m * xG) * p * q
        + Yuv * u * v + m * yG * pow(p, 2) - m * zG * q * r
        + Ydr * pow(u, 2) * rudder;
        
    Z = Zww * w * fabs(w) + Zqq * q * fabs(q) 
        + (Zuq + m) * u * q + (Zvp - m) * v * p 
        + (Zrp - m * xG) * r * p + Zuw * u * w 
        + m * zG * (pow(p, 2) + pow(q, 2)) - m * yG * r * q 
        + Zdp * pow(u, 2) * plane;
        
    K = Kpp * p * fabs(p) - (Izz - Iyy) * q * r
        + m * yG * (u * q - v * p) - m * zG * (w * p - u * r)
        + in(1);
        
    M = Mww * w * fabs(w) + Mqq * q * fabs(q)
        + (Muq - m * xG) * u * q + (Mvp + m * xG) * v * p
        + (Mrp - (Ixx - Izz)) * r * p 
        + m * zG * (v * r - w * q) + Muw * u * w 
        + Mdp * pow(u, 2) * plane;
        
    N = Nvv * v * fabs(v) + Nrr * r * fabs(r) 
        + (Nur - m * xG) * u * r + (Nwp + m * xG) * w * p 
        + (Npq - (Iyy - Ixx)) * p * q 
        - m * yG * (v * r - w * q) + Nuv * u * v 
        + Ndr * pow(u, 2) * rudder;

    Vector forces_HD(6);
    forces_HD(0) = X;
    forces_HD(1) = Y;
    forces_HD(2) = Z;
    forces_HD(3) = K;
    forces_HD(4) = M;
    forces_HD(5) = N;
    
    // total forces on the AUV
    Vector forces = forces_HD + forces_HS;
    
    for(int j=0; j<12; j++)
        fp << x[j] << ",";
    for(int j=0; j<6; j++)
        fp << forces_HD(j) << ",";  
    for(int j=0; j<4; j++)
        fp << in(j) << ",";
    fp << prop_force << "  ,  " << Kt << " , " << J0 << endl;
    
//    cout << forces << endl;
        
    Vector eta_dot = transform_to_earth(nu, phi, theta, psi);
    Vector nu_dot = prod(inv_inertia, forces);
    
    dxdt[0] = eta_dot(0);
    dxdt[1] = eta_dot(1);
    dxdt[2] = eta_dot(2);
    dxdt[3] = eta_dot(3);
    dxdt[4] = eta_dot(4);
    dxdt[5] = eta_dot(5);
    dxdt[6] = nu_dot(0);
    dxdt[7] = nu_dot(1);
    dxdt[8] = nu_dot(2);
    dxdt[9] = nu_dot(3);
    dxdt[10] = nu_dot(4);
    dxdt[11] = nu_dot(5);

}

// motor command callback
void on_motor_command(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const auv_iver_motor_command_t *mc, lcm::LCM *lcm) 
{
    in(0) = mc->main;
    in(1) = 0;
    in(2) = mc->top;
    in(3) = mc->port;
}

// Calculate the path, this is where the magic happens
void calculate(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const heartbeat_t *heartbeat, lcm::LCM *lcm) 
{
    // call the solver
    integrate_n_steps(stepper, auv, state , 0.0 , 0.001 , 100 );
//    integrate(auv, state , 0.0 , 0.1 , 0.001 );
/*    for(int i=0; i<12; i++)
        printf("%2.3f ", state(i));
    printf("\r");
    fflush(NULL);
*/    
    // publish the nav message
    auv_acfr_nav_t nav;
    nav.utime = timestamp_now();
    nav.x = state(0);
    nav.y = state(1);
    nav.depth = state(2);
    nav.roll = state(3);
    nav.pitch = state(4);
    nav.heading = state(5);
    nav.vx = state(6);
    nav.vy = state(7);
    nav.vz = state(8);
    nav.rollRate = state(9);
    nav.pitchRate = state(10);
    nav.headingRate = state(11);
    
    nav.altitude = WATER_DEPTH - nav.depth;

    lcm->publish("ACFR_NAV", &nav);
    
}

int main_exit;
void signal_handler(int sig)
{
    main_exit = 1;
}

int main(int argc, char **argv)
{

    // install the signal handler
    main_exit = 0;
    signal(SIGINT, signal_handler);

    lcm::LCM lcm;  
    lcm.subscribeFunction("IVER_MOTOR", on_motor_command, &lcm);
    lcm.subscribeFunction("HEARTBEAT_10HZ", calculate, &lcm);
    
    populate_inv_inertia();    
    
    // initial conditions
    state(0) = 0;
    state(1) = 0;
    state(2) = 1;  //Z = 10;
    state(3) = 0;
    state(4) = 0;
    state(5) = 0;
    state(6) = 0;
    state(7) = 0;
    state(8) = 0;
    state(9) = 0;
    state(10) = 0;
    state(11) = 0;
    
    in(0) = 0;
    in(1) = 0;
    in(2) = 0;
    in(3) = 0;
/*    
    Vector p(3);
    p(0) = 1;
    p(1) = 2;
    p(2) = 3;
    cout << transform_to_body(p, M_PI/8,M_PI/8,0);
*/    
    fp.open("/tmp/log.txt", ios::out);    

    int fd = lcm.getFileno();
    fd_set rfds;
    while(!main_exit)
    {
        FD_ZERO (&rfds);
        FD_SET (fd, &rfds);
        struct timeval timeout;
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        int ret = select (fd + 1, &rfds, NULL, NULL, &timeout);
        if(ret > 0)
            lcm.handle();
    }
    fp.close();
    return 0;
}

