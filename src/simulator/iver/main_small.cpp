// Iver simulator


#include <iostream>
#include <fstream>
#include <lcm/lcm-cpp.hpp>
#include <signal.h>
#include <boost/numeric/odeint.hpp>
#include <small/Pose3D.hh>
#include "perls-lcmtypes++/perllcm/heartbeat_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_acfr_nav_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_iver_motor_command_t.hpp"
#include "perls-common/timestamp.h"

using namespace std;
using namespace boost::numeric::odeint;
using namespace acfrlcm;
using namespace perllcm;

// generated by matlab
#include "vehicle_params_small.h"

#define Kdp 0.01

#define WATER_DEPTH 30

typedef boost::numeric::ublas::vector< double > state_type;

// Inertial Matrix
SMALL::Matrix33 longM, latM;

// state vectors
state_type state(12);
runge_kutta_cash_karp54<state_type> stepper;

ofstream fp;


// the state vector is X Y Z r p h u v w p q r
// the control vector is RPM prop_torque rudder, plane
SMALL::Vector6D in;

void auv( const state_type &x , state_type &dxdt , const double /* t */ )
{
    double Xa, Ya, Za;
    double u, v, w, p, q, r;
    double phi, theta, psi;
    Xa = x[0];
    Ya = x[1];
    Za = x[2];
    phi = x[3];
    theta = x[4];
    psi = x[5];
    u = x[6];
    v = x[7];
    w = x[8];
    p = x[9];
    q = x[10];
    r = x[11];
    
    SMALL::Vector4D nuLinear, nuRotational;
    nuLinear = u, v, w, 0.0;
    nuRotational = p, q, r, 0.0;

    // make heading 0 to 2pi
    while(psi < 0)
        psi += 2 * M_PI;
    while(psi > (2 * M_PI))
        psi -= 2 * M_PI;

            
    // Where we are at, ie the auv pose
    SMALL::Pose3D auvPose;
    auvPose.setPosition(Xa, Ya, Za);
    auvPose.setRollPitchYawRad(phi, theta, psi);




    // Prop force calculations       
    double prop_alpha = 0.02290; //0.01;
    double prop_diameter = 0.085;
    double rho = 1030;              // Water density
    double J0 = 0; // open water advance coefficient
    double Kt = 0; // propeller torque coefficient
    
    // Sanity check on input
    if(in(0) != in(0))
    {
        in(0) = 0;
        cerr << "In 0 NaN" << endl;
    }
    
    // propeller revolutions per second (rps)
    // converting desired rpm to rps
    double n = in(0)/60;
    
    // limit the max rpm to 1500 = 25 rps
    if(fabs(n) > 25)
        n = n / fabs(n) * 25;
    
    
    // advance velocity as per Fossen eq 4.6
    double omega = 0.1;
    double Va = (1 - omega) * u;
    
    if(fabs(n) > 1e-3)
        J0 = Va / (n * prop_diameter);      // as per Fossen eq 6.107

    double alpha1 = 0.5;
    double alpha2 = -4.0/11.0;
	double alpha3 = (0.45 - alpha1)/(-0.2);
	double alpha4 = 0.45 -(-0.2* (0.95-0.45) / (-0.5-(-0.2)) );
	double alpha5 = (0.95-0.45) / (-0.5-(-0.2));

    if (J0 > 0) 
    	Kt = alpha1 + alpha2 * J0;   // Fossen eq 6.113
	else if (J0 > -0.2)
		Kt = alpha1 + alpha3 * J0;			// Fossen eq 6.113
	else
		Kt = alpha4 + alpha5 * J0; // Fossen eq 6.113
        
    double prop_force;
    prop_force = rho * pow(prop_diameter,4) * Kt * fabs(n) * n;     // As per Fossen eq 4.2
//    cout << "n = " << n << " Va = " << Va << " J0 = " << J0 << " Kt = " << Kt << " F = " << prop_force << endl;
    if(prop_force !=  prop_force)
    {
        cerr << "Prop force error" << endl;
        prop_force = 0;
    }
    if(fabs(prop_force) > 10.0)
        prop_force = prop_force / fabs(prop_force) * 10;
    
    
    
    // set the fins to zero is we aren't moving as the model doesn't behave
    double top, bottom, port, starboard;
    top = in(2);
    bottom = in(3);
    port = in(4);
    starboard = in(5);

    // external applied forces
    double X, Y, Z, K, M, N;
    X = prop_force;
    Y = Ydr * pow(u, 2) * (top + bottom);
    Z = Zdp * pow(u, 2) * (port + starboard);
    K = Kdp * pow(u, 2) * ((top - bottom) + (port - starboard));
    M = Mdp * pow(u, 2) * (port + starboard);
    N = Ndr * pow(u, 2) * (top + bottom);

    // Force vectors, props and control surfaces
    SMALL::Vector3D longF, latF;
    longF = X, Z, M;
    latF = Y, K, N;

    
    // Hydrodynamic Forces and Moments
/*    
    X = Xuu * u * fabs(u) + (Xwq - m) * w * q 
        + (Xqq + m * xG) * pow(q, 2) + (Xvr + m) * v * r 
        + (Xrr + m * xG) * pow(r, 2) - m * yG * p * q 	
        - m * zG * p * r + prop_force;
        
    Y = Yvv * v * fabs(v) + Yrr * r * fabs(r)
        + m * yG * pow(r, 2) + (Yur - m) * u * r
        + (Ywp + m) * w * p + (Ypq - m * xG) * p * q
        + Yuv * u * v + m * yG * pow(p, 2) - m * zG * q * r
        + Ydr * pow(u, 2) * rudder;
        
    Z = Zww * w * fabs(w) + Zqq * q * fabs(q) 
        + (Zuq + m) * u * q + (Zvp - m) * v * p 
        + (Zrp - m * xG) * r * p + Zuw * u * w 
        + m * zG * (pow(p, 2) + pow(q, 2)) - m * yG * r * q 
        + Zdp * pow(u, 2) * plane;
        
    K = Kpp * p * fabs(p) - (Izz - Iyy) * q * r
        + m * yG * (u * q - v * p) - m * zG * (w * p - u * r)
        + in(1);
        
    M = Mww * w * fabs(w) + Mqq * q * fabs(q)
        + (Muq - m * xG) * u * q + (Mvp + m * xG) * v * p
        + (Mrp - (Ixx - Izz)) * r * p 
        + m * zG * (v * r - w * q) + Muw * u * w 
        + Mdp * pow(u, 2) * plane;
        
    N = Nvv * v * fabs(v) + Nrr * r * fabs(r) 
        + (Nur - m * xG) * u * r + (Nwp + m * xG) * w * p 
        + (Npq - (Iyy - Ixx)) * p * q 
        - m * yG * (v * r - w * q) + Nuv * u * v 
        + Ndr * pow(u, 2) * rudder;
*/

    // For decoupled lateral and longitudinal forces as per Fossen 7.5.6    

    // Velocity vectors, current state
    SMALL::Vector3D longV, latV;
    longV = u, w, q;
    latV = v, p, r;
    
    // Damping matrices modified to match the above equations
    SMALL::Matrix33 longDv, latDv;
    longDv = -Xuu * fabs(u), 						-Xwq * q, 					-Xqq * fabs(q), 
    		 -Zuq * q - Zuw * w, 					-Zww * fabs(w), 			-Zqq * fabs(q),
    		 - Muq * q - Muw * w, 					-Mww * fabs(w), 			-Mqq * fabs(q);
    
    latDv = -Yvv * fabs(v) - Yuv * u,	-Ywp * w - Ypq * q, 					-Yrr * fabs(r) - Yur * u,
    		0, 							-Kpp * fabs(p), 						0,
//			-Mvp * p, 					-Mpp * fabs(p), 						-Mrp * p,
    		-Nvv * fabs(v) - Nuv * u, 	- Nwp * w - Npq * q, 					-Nrr * fabs(r) - Nur * u;
    
    // Damping matrices
    /*
	SMALL::Matrix33 longDv, latDv;
    longDv = -Xuu * fabs(u), 						-Xwq * q, 					-Xqq * fabs(q) - Xwq * w, 
    		 -Zuq * q - Zuw * w, 					-Zww * fabs(w) - Zuw * u, 	-Zqq * fabs(q),
    		 -Muu * fabs(u) - Muq * q - Muw * w, 	-Mww * fabs(w), 			-Mqq * fabs(q);
    
    latDv = -Yvv * fabs(v), 			-Ywp * w - Ypq * q, 					-Yrr * fabs(r) - Yur * r,
    		-Mvp * p, 					-Mpp * fabs(p), 						-Mrp * p,
    		-Nvv * fabs(v) - Nuv * u, 	-Npp * fabs(p) - Nwp * w - Npq * q, 	-Nrr * fabs(r) - Nur * u;
    */

    // Coriolis matrices
    SMALL::Matrix33 longCv, latCv;
    longCv = 	0.0, 		0.0, 					0.0, 
				0.0, 		0.0, 					-(m - Xudot) * u, 
				0.0, 		(Zwdot - Xudot) * u, 	m * xG * u;
    
    latCv = 	0.0, 		0.0, 					(m- Xudot) * u, 
				0.0, 		0.0, 					0.0, 
				(Xudot - Yvdot) * u, 	0.0, 		m * xG * u;
    
    // Gravity and buoyancy
    SMALL::Vector3D longGn, latGn;
    longGn = 0.0, 0.0, W * zG  * sin(theta);
    latGn = 0.0, W * zG * sin(phi), 0.0;
    
/*    cout << "X = ";
        for(int j=0; j<12; j++)
                cout << x[j] << " ";
        cout << endl;
*/    
    SMALL::Vector3D t1, t2;
//    t1 = (longF - longGn - longCv * longV  - longDv * longV);
    t1 = longDv * longV;
    t2 = latDv * latV;
//    t2 = (latF - latGn - latCv * latV - latDv * latV);
//    cout << "F = " << t1(1) << " " << t2(1) << " " << t1(2) << " " << t2(2) << " " << t1(3) << " " << t2(3) << " "<< endl;
    
/*
    cout << "longF = " << longF.toString() << endl;
    cout << "longGn = " << longGn.toString() << endl;
    cout << "longDv = " << t1.toString() << endl;
    cout << "longCv = " << (longCv * latV).toString() << endl;
    cout << "latF = " << latF.toString() << endl;
    cout << "latGn = " << latGn.toString() << endl;
    cout << "latDv = " << t2.toString() << endl;
    cout << "latCv = " << (latCv * latV).toString() << endl;
    cout << endl;
*/    
    SMALL::Vector3D longDot, latDot;
    longDot = (longF - longGn - longCv * longV - longDv * longV) / longM;
    latDot = (latF - latGn - latCv * latV - latDv * latV) / latM;

    // Rotate the velocites to the world frame        
    SMALL::Vector3D etaDotLin;//, etaDotRot;
    etaDotLin = (auvPose.get3x4TransformationMatrix() * nuLinear);
    //etaDotRot = (auvPose.get3x4TransformationMatrix() * nuRotational); // will be unused, as the Euler rates transform is used below
    
    SMALL::Vector6D nu_dot;
    nu_dot = longDot[0], latDot[0], longDot[1], latDot[1], longDot[2], latDot[2];
    
    
    dxdt[0] = etaDotLin[0];
    dxdt[1] = etaDotLin[1];
    dxdt[2] = etaDotLin[2];
    dxdt[3] = p + q*cos(phi)*tan(theta) + r*sin(phi)*tan(theta); //etaDotRot[0]; 
    dxdt[4] = q*cos(phi) - r*sin(phi); //etaDotRot[1];
    dxdt[5] = q*sin(phi)/cos(theta) + r*cos(phi)/cos(theta); //etaDotRot[2];
    dxdt[6] = nu_dot[0];
    dxdt[7] = nu_dot[1];
    dxdt[8] = nu_dot[2];
    dxdt[9] = nu_dot[3];
    dxdt[10] = nu_dot[4];
    dxdt[11] = nu_dot[5];

}

// motor command callback
void on_motor_command(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const auv_iver_motor_command_t *mc, lcm::LCM *lcm) 
{
    in(0) = mc->main;
    in(1) = 0;
    in(2) = mc->top;// / 180.0 * M_PI;
    in(3) = mc->bottom;
    in(4) = mc->port;// / 180.0 * M_PI;
    in(5) = mc->starboard;
}

// Calculate the path, this is where the magic happens
void calculate(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const heartbeat_t *heartbeat, lcm::LCM *lcm) 
{
    // call the solver
//    integrate_n_steps(stepper, auv, state , 0.0 , 0.001 , 100 );
//    integrate_const(stepper, auv, state , 0.0 , 0.1 , 0.001 ); // 1x speed simulation
    integrate_const(stepper, auv, state , 0.0 , 0.1 , 0.001 ); // 5x speed simulation
    for(int i=0; i<12; i++) {
        printf("%2.3f ", state(i));
		fp << state(i) << " ";
	}
	for(int i=0; i<6; i++) {
		printf("%2.3f ", in(i));
		fp << in(i) << " ";
	}

	fp << "\n";
    printf("\n");
    fflush(NULL);
    
    // publish the nav message
    auv_acfr_nav_t nav;
    nav.utime = timestamp_now();
    nav.x = state(0);
    nav.y = state(1);
    nav.depth = state(2);
    nav.roll = state(3);
    nav.pitch = state(4);
    nav.heading = state(5);
    nav.vx = state(6);
    nav.vy = state(7);
    nav.vz = state(8);
    nav.rollRate = state(9);
    nav.pitchRate = state(10);
    nav.headingRate = state(11);
    
    nav.altitude = WATER_DEPTH - nav.depth;

    lcm->publish("ACFR_NAV", &nav);
    
}

int main_exit;
void signal_handler(int sig)
{
    main_exit = 1;
}

int main(int argc, char **argv)
{

    // install the signal handler
    main_exit = 0;
    signal(SIGINT, signal_handler);

    lcm::LCM lcm;  
    lcm.subscribeFunction("IVER_MOTOR", on_motor_command, &lcm);
    lcm.subscribeFunction("HEARTBEAT_10HZ", calculate, &lcm);
    
    //populate_inv_inertia();
    
    // Interial matrices
    longM = m - Xudot, 			-Xwdot, 			m * zG - Xqdot,
    		-Xwdot, 			m - Zwdot, 			-m * xG - Zqdot,
    		m * zG - Xqdot, 	-m * xG - Zqdot, 	Iy - Mqdot;
    
    latM = 	m - Yvdot,			-m * zG - Ypdot,	m * xG - Yrdot,
    		-m * zG - Ypdot,	Ix - Kpdot,			-Izx - Krdot,
    		m * xG - Yrdot,		-Izx - Krdot,		Iz - Nrdot;
    
    // initial conditions
    state(0) = 0;
    state(1) = 0;
    state(2) = 1;  //Z = 1;
    state(3) = 0;
    state(4) = 0;
    state(5) = 0;
    state(6) = 0;
    state(7) = 0;
    state(8) = 0;
    state(9) = 0;
    state(10) = 0;
    state(11) = 0;
    
    in(0) = 0;
    in(1) = 0;
    in(2) = 0;
    in(3) = 0;
    fp.open("/tmp/log.txt", ios::out);    

    int fd = lcm.getFileno();
    fd_set rfds;
    while(!main_exit)
    {
        FD_ZERO (&rfds);
        FD_SET (fd, &rfds);
        struct timeval timeout;
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        int ret = select (fd + 1, &rfds, NULL, NULL, &timeout);
        if(ret > 0)
            lcm.handle();
    }
    fp.close();
    return 0;
}

