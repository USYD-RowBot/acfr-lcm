// nga AUV simulator


#include <iostream>
#include <fstream>
#include <lcm/lcm-cpp.hpp>
#include <csignal>
#include <boost/numeric/odeint.hpp>
#include <small/Pose3D.hh>
#include <bot_param/param_client.h>
#include "acfr-common/auv_map_projection.hpp"
#include <libplankton/auv_config_file.hpp>
#include "perls-lcmtypes++/perllcm/heartbeat_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_acfr_nav_t.hpp"
#include "perls-lcmtypes++/senlcm/tcm_t.hpp"
#include "perls-lcmtypes++/senlcm/ysi_t.hpp"
#include "perls-lcmtypes++/senlcm/parosci_t.hpp"
#include "perls-lcmtypes++/senlcm/gpsd3_t.hpp"
#include "perls-lcmtypes++/senlcm/rdi_pd5_t.hpp"
#include "perls-lcmtypes++/senlcm/IMU_t.hpp"
#include "perls-lcmtypes++/senlcm/os_power_system_t.hpp"
#include "perls-lcmtypes++/senlcm/os_power_cont_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_bluefin_tail_status_t.hpp"
#include "perls-lcmtypes++/senlcm/micron_sounder_t.hpp"



using namespace std;
using namespace boost::numeric::odeint;
using namespace acfrlcm;
using namespace perllcm;
using namespace senlcm;
using namespace libplankton;

// generated by matlab
//#include "vehicle_params_small.h"

namespace vehicleSimSimple
{
#define Kdp 0.01
//#define CURRENT 0.1
#define CURRENT 0.0
#define WATER_DEPTH 30

#define GPS_CHANNELS 4
#define MAG_VAR 12.67*M_PI/180
#define TAU_A 500
#define TAU_G 500
#define STD_A 0.0372
#define STD_G 0.00010732
#define BIAS_A 0.0196
#define BIAS_G 9.6963e-06


typedef boost::numeric::ublas::vector< double > state_type;

class VehicleSimBase
{
public:
    VehicleSimBase();
    virtual ~VehicleSimBase();

    void setVehicleName(string vehName);
    string const getVehicleName() const;

    void run();

protected:
    // Calculate the path, this is where the magic happens
    void calculate(); 
    virtual void updateState( const state_type &x , state_type &dxdt , const double /* t */ ) = 0;

    // virtual functions for derived classes to decide on data to be published
    virtual void publishSensorData() = 0;
    
    // functions to publish the current sensor data
    void publishACFRNav();
    void publishIMU();
    void publishTCM();
    void publishYSI();
    void publishParosci();
    void publishGPS();
    void publishDVL();
    void publishBattery();
    void publishBluefinTail();
    void publishDWN_OAS();


    // virtual function for derived classes to decide on channels to be subscribed to 
    //virtual void subscribeLCMChannels();
    virtual void subscribeLCMChannels() = 0;

    // state vectors
    state_type state;

    lcm::LCM lcm;
    string vehicle_name;
private:
    BotParam *param = NULL;

	
    

    void lcm_thread();

    // Inertial Matrix
    SMALL::Matrix33 longM, latM;

    runge_kutta_cash_karp54<state_type> stepper;
    auv_acfr_nav_t nav;

    SMALL::Vector3D accel;

    Local_WGS84_TM_Projection *map_projection_sim;

    int64_t last_dvl_time;
    int64_t last_gps_time;
    int64_t last_ysi_time;
    int64_t last_tcm_time;
    int64_t last_print_time;
    int64_t last_obs_time;
    int64_t last_parosci_time;
    int64_t last_battery_time;
    int64_t last_bluefin_time;
    int64_t last_dwn_oas_time;

    // earth rotation in the navigation frame
    SMALL::Vector3D earth_rot;

    //gravity
    SMALL::Vector3D grav;

    // the state vector is X Y Z r p h u v w p q r
    #define XNDX 0
    #define YNDX 1
    #define ZNDX 2
    #define ROLLNDX 3
    #define PITCHNDX 4
    #define HDGNDX 5
    #define XDOTNDX 6
    #define YDOTNDX 7
    #define ZDOTNDX 8
    #define ROLLDOTNDX 9
    #define PITCHDOTNDX 10
    #define HDGDOTNDX 11

    double ba_x,ba_y,ba_z,bg_x,bg_y,bg_z;

    long long int interval_us;
    double time_step;
};

}
