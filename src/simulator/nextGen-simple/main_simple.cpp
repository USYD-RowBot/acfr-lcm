// nga AUV simulator


#include <iostream>
#include <fstream>
#include <lcm/lcm-cpp.hpp>
#include <signal.h>
#include <boost/numeric/odeint.hpp>
#include <small/Pose3D.hh>
#include <bot_param/param_client.h>
#include "acfr-common/auv_map_projection.hpp"
#include "perls-lcmtypes++/perllcm/heartbeat_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_acfr_nav_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_nga_motor_command_t.hpp"
#include "perls-common/timestamp.h"
#include "perls-lcmtypes++/senlcm/tcm_t.hpp"
#include "perls-lcmtypes++/senlcm/ysi_t.hpp"
#include "perls-lcmtypes++/senlcm/gpsd3_t.hpp"
#include "perls-lcmtypes++/senlcm/rdi_pd5_t.hpp"
#include "perls-lcmtypes++/senlcm/IMU_t.hpp"
#include "perls-lcmtypes++/senlcm/os_power_system_t.hpp"
#include "perls-lcmtypes++/senlcm/os_power_cont_t.hpp"


#include "simulator-common/vehicleSimBase.hpp"

using namespace std;
using namespace boost::numeric::odeint;
using namespace acfrlcm;
using namespace perllcm;
using namespace senlcm;
using namespace libplankton;
using namespace vehicleSimSimple;

// generated by matlab
#include "vehicle_params_small.h"

#define NGA_DIAM 0.3 
#define NGA_RADIUS (0.5*NGA_DIAM)
#define NGA_LENGTH 2.5 
#define NGA_VERT_DISTANCE 2 
#define NGA_LAT_DISTANCE 1.8 
#define NGA_MASS 120 
#define NGA_INERTIA ((0.0833*NGA_MASS*NGA_LENGTH*NGA_LENGTH) + (0.25*NGA_MASS*NGA_DIAM*NGA_DIAM))

class NGAVehicleSim : public VehicleSimBase
{
public:
    NGAVehicleSim();
    virtual ~NGAVehicleSim() = default;

protected:
    virtual void updateState( const state_type &x , state_type &dxdt , const double /* t */);

    virtual void publishSensorData();

    virtual void subscribeLCMChannels();
    
    void on_motor_command(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const auv_nga_motor_command_t *mc);

private:
    auv_nga_motor_command_t motor_cmd_in;
};

NGAVehicleSim::NGAVehicleSim()
{
}

void NGAVehicleSim::updateState( const state_type &x , state_type &dxdt , const double )
{
    double Xa, Ya, Za;
    double u, v, w, p, q, r;
    double phi, theta, psi;
    Xa = x[XNDX];
    Ya = x[YNDX];
    Za = x[ZNDX];
    phi = x[ROLLNDX];
    theta = x[PITCHNDX];
    psi = x[HDGNDX];
    u = x[XDOTNDX];
    v = x[YDOTNDX];
    w = x[ZDOTNDX];
    p = x[ROLLDOTNDX];
    q = x[PITCHDOTNDX];
    r = x[HDGDOTNDX];
    
    auv_nga_motor_command_t in = this->motor_cmd_in;

    // adjustments for a constant water current (or wind)

    SMALL::Rotation3D Cbn;
    Cbn.setRollPitchYawRad(phi, theta, psi);

    // current in the navigation frame
    SMALL::Vector3D vc_n;
    vc_n = CURRENT,0,0;
    // current in the body frame
    SMALL::Vector3D vc_b;
    vc_b = (Cbn.i() * vc_n);

    // vehicle velocity in the current
    u = u - vc_b(1);
    v = v - vc_b(2);
    w = w - vc_b(3);

    // make heading 0 to 2pi
    while(psi < 0)
        psi += 2 * M_PI;
    while(psi > (2 * M_PI))
        psi -= 2 * M_PI;

    // Where we are at, ie the auv pose
    SMALL::Pose3D auvPose;
    auvPose.setPosition(Xa, Ya, Za);
    auvPose.setRollPitchYawRad(phi, theta, psi);

    // Prop force calculations
    double prop_alpha = 0.02290; //0.01; // advance ratio
    double prop_diameter = 0.25;
    double rho = 1030;              // Water density
    double J0 = 0; // open water advance coefficient
    double Kt = 0; // propeller thrust coefficient
    double Kq = 0; // properler torque coefficient
    
   
    // **************************
    // * Prop force from the tail
    // *************************
    //
    // propeller revolutions per second (rps)
    // converting desired rpm to rps
    double n = in.tail_thruster/60;
    
    // limit the max rpm to 1500 = 25 rps
    if(fabs(n) > 25)
        n = n / fabs(n) * 25;
    
    // advance velocity as per Fossen eq 4.6
    double omega = 0.1;
    double Va = (1 - omega) * u;
    
    if(fabs(n) > 1e-3)
        J0 = Va / (n * prop_diameter);      // as per Fossen eq 6.107

    double alpha1 = 0.5;
    double alpha2 = -4.0/11.0;
    double alpha3 = (0.45 - alpha1)/(-0.2);
    double alpha4 = 0.45 -(-0.2* (0.95-0.45) / (-0.5-(-0.2)) );
    double alpha5 = (0.95-0.45) / (-0.5-(-0.2));

    // these need to be determined
    // but relate to the torque from the rear thruster
    // not sure but it may result in a torque not around
    // the x-axis of the vehicle
    double beta1 = 0.0;
    double beta2 = -0.0;

    if (J0 > 0)
    {
        Kt = alpha1 + alpha2 * J0;   // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else if (J0 > -0.2)
    {
        Kt = alpha1 + alpha3 * J0;			// Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else
    {
        Kt = alpha4 + alpha5 * J0; // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }

    double prop_force;//, prop_torque;
    prop_force = rho * pow(prop_diameter,4) * Kt * fabs(n) * n;     // As per Fossen eq 4.2
    //prop_torque = rho * pow(prop_diameter,5) * Kq * fabs(n) * n; // Fossen 6.113
    //    cout << "n = " << n << " Va = " << Va << " J0 = " << J0 << " Kt = " << Kt << " F = " << prop_force << endl;
    if(prop_force !=  prop_force)
    {
        cerr << "Prop force error" << endl;
        prop_force = 0;
    }
    //if(fabs(prop_force) > 10.0)
    //    prop_force = prop_force / fabs(prop_force) * 10;
    
    double tail_x = prop_force * cos(-in.tail_rudder) * cos(in.tail_elevator); //assuming rudder straight is 0 and max range is +-pi/2 the negative sign in cos won't matter
    double tail_y = prop_force * sin(-in.tail_rudder) ;//* cos(in.tail_elevator); //CR why is elevator a component of tail y?
    double tail_z = prop_force * sin(in.tail_elevator);


    // ****************************************
    // * Tunnel thruster forces
    // * **************************************
    // the tunnel thruster forces needs to be determined as well
    // the lateral components affect yaw - psi and motion in y
    // the vertical components affect pitch - theta and motion in z
    // there is no effect on surge motion or roll
    //
    double tunnel_diameter = 0.1;

    //
    // there is ZERO basis for this number (we use +-1500, full range is +-2048
    // from the DAC
    double to_rps = 0.03; // if we are just converting from RPM to RPS then shouldn't this be 1/60 not 1/30?

    double n_vert_fore = in.vert_fore * to_rps;
    double vert_fore_force = rho * pow(tunnel_diameter,4) * Kt * fabs(n_vert_fore) * n_vert_fore;
    double n_vert_aft = in.vert_aft * to_rps;
    double vert_aft_force = rho * pow(tunnel_diameter,4) * Kt * fabs(n_vert_aft) * n_vert_aft;
    double n_lat_fore = in.lat_fore * to_rps;
    double lat_fore_force = rho * pow(tunnel_diameter,4) * Kt * fabs(n_lat_fore) * n_lat_fore;
    double n_lat_aft = in.lat_aft * to_rps;
    double lat_aft_force = rho * pow(tunnel_diameter,4) * Kt * fabs(n_lat_aft) * n_lat_aft;

    double mutual_vert = vert_fore_force + vert_aft_force;
    double differential_vert = vert_fore_force - vert_aft_force;

    double mutual_lat = lat_fore_force + lat_aft_force;
    double differential_lat = lat_fore_force - lat_aft_force;

  
    // ***********
    // Drag forces
    // ***********
    double Cd_surge = 3; //0.82; // modelled on a long cylinder
    double A_surge = M_PI * pow(NGA_RADIUS,2); // submerged
    double Cd_across = 5; //1.17; // modelled on a long cylinder
    double A_across = (NGA_DIAM * NGA_LENGTH);
    
    double Fd_surge = 0.5 * rho * A_surge * Cd_surge * fabs(u) * u ;
    double Fd_sway = 0.5 * rho * A_across * Cd_across * fabs(v) * v;
    double Fd_vert = 0.5 * rho * A_across * Cd_across * fabs(w) * w;
   
    // *************************
    // Gravity and Buoyant Force
    // *************************
    double F_g = NGA_MASS*9.81;
    double A_sub = M_PI * pow(NGA_RADIUS,2);
    double A_breach = 0;
    // Assume that depth is measured at the middle of the vehicle
    if (x[ZNDX] < NGA_RADIUS)
    {
        A_breach = pow(NGA_RADIUS,2) * acos(x[ZNDX]/(NGA_RADIUS)) - x[ZNDX]*sqrt(pow(NGA_RADIUS,2)-pow(x[ZNDX],2));
        A_sub -= A_breach;
    }
    double F_buoy = 0.66 * rho * A_sub * NGA_LENGTH * 9.81; // model the buoyancy to be slightly higher than the force of gravity when fully submerged


    //cout << " F_buoy: " << F_buoy << " A_breach: " << A_breach << " A_sub: " << A_sub << endl;

    // *************************
    // External applied forces
    // *************************
    double F_surge, F_sway, F_vert;
    F_surge = tail_x - Fd_surge;
    F_sway = tail_y + mutual_lat - Fd_sway;
    F_vert = tail_z + mutual_vert - Fd_vert  + F_g - F_buoy;

    // *************************
    // Applied torques 
    // *************************
    // model the vehicle as a long cylinder spinning in a fluid
    // treat the cylinder as a series of disks of the diameter of the vehicle 
    // and of thickness dR.  The velocity through water of each disk is related to the
    // angular velocity w by the distance to the centre R.  
    //  dF_drag = 0.5 * Cd * rho * (Rw)^2 * Diam * dR (where R is the distance from the centre of the vehicle)
    //
    // Integrating the drag along the length from the centre, we have:
    //  T_drag = 1/3 * Cd * rho * Diam * w^2 * (L/2)^3
    //
    double Td_hdg = 0.333 * Cd_across * rho *  (NGA_DIAM) * fabs(r) * r * pow(0.5*NGA_LENGTH,3); 
    //double Td_hdg = 100000 * fabs(r) * r;
    double T_hdg = ((-tail_y * 0.5*NGA_LENGTH) + (differential_lat*0.5*NGA_LAT_DISTANCE) - Td_hdg);
   
    double Td_pitch = 0.333 * Cd_across * rho *  (NGA_DIAM) * fabs(q) * q * pow(0.5*NGA_LENGTH,3); 
    //double Td_pitch = 100000 * fabs(q) * q; 

    double d_buoy_centre = 0.1; // assume the buoyancy and gravity each act centered at around 10cm from the centre of the vehicle
    double T_buoy = F_buoy * d_buoy_centre * sin(x[PITCHNDX]);
    double T_g = F_g * d_buoy_centre * sin(x[PITCHNDX]);

    double T_pitch = ((-tail_z * 0.5 * NGA_LENGTH) + (differential_vert* 0.5 * NGA_LAT_DISTANCE) - Td_pitch - T_buoy - T_g);

    // update the rates of change of the system states
    dxdt[XNDX] = u*cos(psi);
    dxdt[YNDX] = u*sin(psi);
    dxdt[ZNDX] = w;
    dxdt[ROLLNDX] = p;
    dxdt[PITCHNDX] = q;
    dxdt[HDGNDX] = r;
    dxdt[XDOTNDX] = F_surge/NGA_MASS;
    dxdt[YDOTNDX] = F_sway/NGA_MASS;
    dxdt[ZDOTNDX] = F_vert/NGA_MASS;
    dxdt[ROLLDOTNDX] = 0;
    dxdt[PITCHDOTNDX] = T_pitch / NGA_INERTIA;  // FIXME: Need to account for pitch here
    dxdt[HDGDOTNDX] = T_hdg / NGA_INERTIA;

    static int loopCount = 0;

    if (loopCount++ > 100)
    {
        cout << "x: " << x[XNDX] << " y: " << x[YNDX] << " z: " << x[ZNDX] << " roll: " << x[ROLLNDX] << " pitch: " << x[PITCHNDX] << " hdg: " << x[HDGNDX] << endl;
        cout << "u: " << u << " v: " << v << " w: " << w << " p: " << p << " q: " << q << " r: " << r << endl;
        cout << "Fsurge: " << F_surge << " F_sway:" << F_sway << " F_vert:" << F_vert << " prop_force: " << prop_force << " tailRudder: " << in.tail_rudder << " tailElev: " << in.tail_elevator << endl;
        cout << " Fd_vert: " << Fd_vert << " F_g: " << F_g << " F_buoy: " << F_buoy << endl;
        cout << " tail_x: " << tail_x << " tail_y: " << tail_y << " tail_z: " << tail_z << endl;
        cout << " vert_fore_force: " << vert_fore_force << " vert_aft_force: " << vert_aft_force << endl; 
        cout << " mutual_vert: " << mutual_vert << " differential_vert: " << differential_vert << endl;
        cout << " lat_fore_force: " << lat_fore_force << " lat_aft_force: " << lat_aft_force << endl; 
        cout << " mutual_lat: " << mutual_lat << " differential_lat: " << differential_lat << endl;
        cout << "T_hdg: " << T_hdg << " Td_hdg: " << Td_hdg << endl;
        cout << "T_pitch: " << T_pitch << " Td_pitch: " << Td_pitch << " T_buoy: " << T_buoy << " T_g: " << T_g <<  endl;
        cout << "dx:" << dxdt[XNDX] << " dy:" << dxdt[YNDX] << " dz: " << dxdt[ZNDX] << " droll: " << dxdt[ROLLNDX] << " dpitch: " << dxdt[PITCHNDX] << " dhdg: " << dxdt[HDGNDX] << endl;
        cout << "dxdot: " << dxdt[XDOTNDX] << " dydot: " << dxdt[YDOTNDX] << " dzdot: " << dxdt[ZDOTNDX] << " drolldot: " << dxdt[ROLLDOTNDX] << " dpitchdot: " << dxdt[PITCHDOTNDX] <<  " dhdgdot:" << dxdt[HDGDOTNDX] << endl;
        loopCount = 0;
    }
}

// motor command callback
void NGAVehicleSim::on_motor_command(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const auv_nga_motor_command_t *mc) 
{
    motor_cmd_in = *mc;
}


void NGAVehicleSim::publishSensorData()
{
    //publishACFRNav();
    //publishIMU();
    publishTCM();
    publishParosci();
    publishGPS();
    publishDVL();

      // publish battery data
  senlcm::os_power_system_t battery_pack;
  battery_pack.utime = timestamp_now();
  battery_pack.avg_charge_p = 100;
  // need to have number of controllers set or you get a seg fault when publishing sometimes.
  battery_pack.num_controllers = 0;
  lcm.publish("NGA.BATTERY", &battery_pack);
}

void NGAVehicleSim::subscribeLCMChannels()
{
    lcm.subscribe(vehicle_name+".NEXTGEN_MOTOR", &NGAVehicleSim::on_motor_command, this);
    // lcm.subscribeFunction("HEARTBEAT_10HZ", calculate, &lcm);
    // lcm.subscribeFunction("HEARTBEAT_100HZ", calculate, &lcm); // needs to happen at 100 Hz due to IMU
    // lcm.subscribeFunction(vehicle_name+".ACFR_NAV", on_nav_store, &lcm);
}

void print_help (int exval, char **argv)
{                                                                               
    printf("Usage:%s [-h] [-n VEHICLE_NAME]\n\n", argv[0]);                     
    
    printf("  -h                               print this help and exit\n");    
    printf("  -n VEHICLE_NAME                  set the vehicle_name\n");        
    exit (exval);                                                               
}                                                                               
                                                                                
void                                                                            
parse_args (int argc, char **argv, vehicleSimSimple::VehicleSimBase &vehicleSim)                                              
{                                                                            
    int opt;                                                                    
                                                                                
    while ((opt = getopt (argc, argv, "hn:")) != -1)                            
    {                                                                           
        switch(opt)                                                             
        {                                                                       
            case 'h':                                                               
                print_help (0, argv);                                               
                break;                                                              
            case 'n':                                                               
                vehicleSim.setVehicleName((char*)optarg);                                       
                break;                                                              
         }                                                                      
    }                                                                           
}
        
int main_exit;
void signal_handler(int sig)
{
    main_exit = 1;
}

int main(int argc, char **argv)
{
    NGAVehicleSim vehicleSim;

    parse_args(argc, argv, vehicleSim);

    // install the signal handler
    main_exit = 0;
    signal(SIGINT, signal_handler);

    cout << "Starting sim..." << endl;
    vehicleSim.run();

    return 0;
}



