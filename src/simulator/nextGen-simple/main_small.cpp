// nga AUV simulator


#include <iostream>
#include <fstream>
#include <lcm/lcm-cpp.hpp>
#include <signal.h>
#include <boost/numeric/odeint.hpp>
#include <small/Pose3D.hh>
#include <bot_param/param_client.h>
#include "acfr-common/auv_map_projection.hpp"
#include "perls-lcmtypes++/perllcm/heartbeat_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_acfr_nav_t.hpp"
#include "perls-lcmtypes++/acfrlcm/auv_nga_motor_command_t.hpp"
#include "perls-common/timestamp.h"
#include "perls-lcmtypes++/senlcm/tcm_t.hpp"
#include "perls-lcmtypes++/senlcm/ysi_t.hpp"
#include "perls-lcmtypes++/senlcm/gpsd3_t.hpp"
#include "perls-lcmtypes++/senlcm/rdi_pd5_t.hpp"
#include "perls-lcmtypes++/senlcm/IMU_t.hpp"


using namespace std;
using namespace boost::numeric::odeint;
using namespace acfrlcm;
using namespace perllcm;
using namespace senlcm;
using namespace libplankton;

// generated by matlab
#include "vehicle_params_small.h"

#define Kdp 0.01
//#define CURRENT 0.1
#define CURRENT 0.0
#define WATER_DEPTH 30

#define GPS_CHANNELS 4
#define MAG_VAR 12.67*M_PI/180
#define TAU_A 500
#define TAU_G 500
#define STD_A 0.0372
#define STD_G 0.00010732
#define BIAS_A 0.0196
#define BIAS_G 9.6963e-06

#define NGA_DIAM 0.3 // m
#define NGA_LENGTH 2.5 // m
#define NGA_VERT_DISTANCE 2 //m
#define NGA_LAT_DISTANCE 1.8 //m
#define NGA_MASS 120 // kg
#define NGA_INERTIA ((NGA_MASS*NGA_LENGTH*NGA_LENGTH/12) + (NGA_MASS*NGA_DIAM*NGA_DIAM/4))

typedef boost::numeric::ublas::vector< double > state_type;

// Inertial Matrix
SMALL::Matrix33 longM, latM;

// state vectors
state_type state(12);
runge_kutta_cash_karp54<state_type> stepper;

SMALL::Vector3D accel;

ofstream fp, fp_nav;
Local_WGS84_TM_Projection *map_projection_sim;

int64_t last_dvl_time = 4.611686e+18, last_gps_time = 4.611686e+18, last_ysi_time = 4.611686e+18, last_tcm_time = 4.611686e+18, last_print_time = 4.611686e+18; // 2^62
int64_t last_obs_time = 4.611686e+18;

// earth rotation in the navigation frame
SMALL::Vector3D earth_rot;

//gravity
SMALL::Vector3D grav;

// the state vector is X Y Z r p h u v w p q r
#define XNDX 0
#define YNDX 1
#define ZNDX 2
#define ROLLNDX 3
#define PITCHNDX 4
#define HDGNDX 5
#define XDOTNDX 6
#define YDOTNDX 7
#define ZDOTNDX 8
#define ROLLDOTNDX 9
#define PITCHDOTNDX 10
#define HDGDOTNDX 11

//SMALL::Vector6D in;
auv_nga_motor_command_t in;

double ba_x,ba_y,ba_z,bg_x,bg_y,bg_z;

string vehicle_name = "DEFAULT";

void auv( const state_type &x , state_type &dxdt , const double /* t */ )
{
    double Xa, Ya, Za;
    double u, v, w, p, q, r;
    double phi, theta, psi;
    Xa = x[XNDX];
    Ya = x[YNDX];
    Za = x[ZNDX];
    phi = x[ROLLNDX];
    theta = x[PITCHNDX];
    psi = x[HDGNDX];
    u = x[XDOTNDX];
    v = x[YDOTNDX];
    w = x[ZDOTNDX];
    p = x[ROLLDOTNDX];
    q = x[PITCHDOTNDX];
    r = x[HDGDOTNDX];
    
    // adjustments for a constant water current (or wind)

    SMALL::Rotation3D Cbn;
    Cbn.setRollPitchYawRad(phi, theta, psi);

    // current in the navigation frame
    SMALL::Vector3D vc_n;
    vc_n = CURRENT,0,0;
    // current in the body frame
    SMALL::Vector3D vc_b;
    vc_b = (Cbn.i() * vc_n);

    // vehicle velocity in the current
    u = u - vc_b(1);
    v = v - vc_b(2);
    w = w - vc_b(3);

    // make heading 0 to 2pi
    while(psi < 0)
        psi += 2 * M_PI;
    while(psi > (2 * M_PI))
        psi -= 2 * M_PI;

    // Where we are at, ie the auv pose
    SMALL::Pose3D auvPose;
    auvPose.setPosition(Xa, Ya, Za);
    auvPose.setRollPitchYawRad(phi, theta, psi);

    // Prop force calculations
    double prop_alpha = 0.02290; //0.01; // advance ratio
    double prop_diameter = 0.25;
    double rho = 1030;              // Water density
    double J0 = 0; // open water advance coefficient
    double Kt = 0; // propeller thrust coefficient
    double Kq = 0; // properler torque coefficient
    
    // Sanity check on input
    /*if(in(0) != in(0))
    {
        in(0) = 0;
        cerr << "In 0 NaN" << endl;
    }*/
    
    /**************************
     * Prop force from the tail
     **************************/
    //
    // propeller revolutions per second (rps)
    // converting desired rpm to rps
    double n = in.tail_thruster/60;
    
    // limit the max rpm to 1500 = 25 rps
    if(fabs(n) > 25)
        n = n / fabs(n) * 25;
    
    // advance velocity as per Fossen eq 4.6
    double omega = 0.1;
    double Va = (1 - omega) * u;
    
    if(fabs(n) > 1e-3)
        J0 = Va / (n * prop_diameter);      // as per Fossen eq 6.107

    double alpha1 = 0.5;
    double alpha2 = -4.0/11.0;
    double alpha3 = (0.45 - alpha1)/(-0.2);
    double alpha4 = 0.45 -(-0.2* (0.95-0.45) / (-0.5-(-0.2)) );
    double alpha5 = (0.95-0.45) / (-0.5-(-0.2));

    // these need to be determined
    // but relate to the torque from the rear thruster
    // not sure but it may result in a torque not around
    // the x-axis of the vehicle
    double beta1 = 0.0;
    double beta2 = -0.0;

    if (J0 > 0)
    {
        Kt = alpha1 + alpha2 * J0;   // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else if (J0 > -0.2)
    {
        Kt = alpha1 + alpha3 * J0;			// Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }
    else
    {
        Kt = alpha4 + alpha5 * J0; // Fossen eq 6.113
        Kq = beta1 + beta2 * J0;
    }

    double prop_force;//, prop_torque;
    prop_force = rho * pow(prop_diameter,4) * Kt * fabs(n) * n;     // As per Fossen eq 4.2
    //prop_torque = rho * pow(prop_diameter,5) * Kq * fabs(n) * n; // Fossen 6.113
    //    cout << "n = " << n << " Va = " << Va << " J0 = " << J0 << " Kt = " << Kt << " F = " << prop_force << endl;
    if(prop_force !=  prop_force)
    {
        cerr << "Prop force error" << endl;
        prop_force = 0;
    }
    //if(fabs(prop_force) > 10.0)
    //    prop_force = prop_force / fabs(prop_force) * 10;
    
    double tail_x = prop_force * cos(in.tail_rudder) * cos(in.tail_elevator);
    double tail_y = prop_force * sin(in.tail_rudder) * cos(in.tail_elevator);
    double tail_z = prop_force * sin(in.tail_elevator);


    /****************************************
     * Tunnel thruster forces
     * **************************************/
    // the tunnel thruster forces needs to be determined as well
    // the lateral components affect yaw - psi and motion in y
    // the vertical components affect pitch - theta and motion in z
    // there is no effect on surge motion or roll
    //
    double tunnel_diameter = 0.1;

    //
    // there is ZERO basis for this number (we use +-1500, full range is +-2048
    // from the DAC
    double to_rps = 0.03;

    double n_vert_fore = in.vert_fore * to_rps;
    double vert_fore_force = rho * pow(tunnel_diameter,4) * Kt * fabs(n_vert_fore) * n_vert_fore;
    double n_vert_aft = in.vert_aft * to_rps;
    double vert_aft_force = rho * pow(tunnel_diameter,4) * Kt * fabs(n_vert_aft) * n_vert_aft;
    double n_lat_fore = in.lat_fore * to_rps;
    double lat_fore_force = rho * pow(tunnel_diameter,4) * Kt * fabs(n_lat_fore) * n_lat_fore;
    double n_lat_aft = in.lat_aft * to_rps;
    double lat_aft_force = rho * pow(tunnel_diameter,4) * Kt * fabs(n_lat_aft) * n_lat_aft;

    double mutual_vert = vert_fore_force + vert_aft_force;
    double differential_vert = vert_fore_force - vert_aft_force;

    double mutual_lat = lat_fore_force + lat_aft_force;
    double differential_lat = lat_fore_force - lat_aft_force;

  
    // ***********
    // Drag forces
    // ***********
    double Cd_surge = 0.82; // modelled on a long cylinder
    double A_surge = M_PI * pow(NGA_DIAM,2); // submerged
    double Cd_across = 1.17; // modelled on a long cylinder
    double A_across = NGA_DIAM * NGA_LENGTH;
    
    double Fd_surge = 0.5 * rho * A_surge * Cd_surge * fabs(u) * u ;
    double Fd_sway = 0.5 * rho * A_across * Cd_across * fabs(v) * v;
    double Fd_vert = 0.5 * rho * A_across * Cd_across * fabs(w) * w;
   
    // *************************
    // Gravity and Buoyant Force
    // *************************
    double F_g = NGA_MASS*9.81;
    double A_sub = M_PI * pow(NGA_DIAM/2,2);
    if (x[ZNDX] < NGA_DIAM/2)
    {
        double theta_sub = 2 * acos(x[ZNDX]/(NGA_DIAM/2));
        A_sub -= 0.5*pow(NGA_DIAM/2, 2) * theta_sub - sin(theta_sub);
    }
    double F_buoy = 0.66 * rho * A_sub * NGA_LENGTH * 9.81; // model the buoyancy to be slightly higher than the force of gravity when fully submerged

    // external applied forces
    double F_surge, F_sway, F_vert;
    F_surge = tail_x - Fd_surge;
    F_sway = 0;// tail_y + mutual_lat - Fd_sway;
    F_vert = tail_z + mutual_vert - Fd_vert + F_g - F_buoy;

    // applied torques 
    // model the vehicle as a long cylinder spinning in a fluid
    // integrating the drag along the length from the centre, we have
    //  dF = 0.5 * Cd * rho * (Rw)^2 * D * dR (where d is the 
    // integrating this gives us
    //  T = 1/3 * CD * rho * D * w^2 * (L/2)^3
    double Td = Cd_across * rho *  NGA_DIAM * fabs(r) * r * pow(NGA_LENGTH/2,3); 


    double T_hdg = ((-tail_y * NGA_LENGTH/2) + (differential_lat*NGA_LAT_DISTANCE/2) - Td);
   
    // update the rates of change of the system states
    dxdt[XNDX] = u*cos(psi);
    dxdt[YNDX] = u*sin(psi);
    dxdt[ZNDX] = w;
    dxdt[ROLLNDX] = 0;
    dxdt[PITCHNDX] = 0;
    dxdt[HDGNDX] = r;
    dxdt[XDOTNDX] = F_surge/NGA_MASS;
    dxdt[YDOTNDX] = F_sway/NGA_MASS;
    dxdt[ZDOTNDX] = F_vert/NGA_MASS;
    dxdt[ROLLDOTNDX] = 0;
    dxdt[PITCHDOTNDX] = 0;  // FIXME: Need to account for pitch here
    dxdt[HDGDOTNDX] = T_hdg / NGA_INERTIA;

    static int loopCount = 0;

    if (loopCount++ > 100)
    {
        cout << "u: " << u << " v: " << v << " w: " << w << " p: " << p << " q: " << q << " r: " << r << endl;
        cout << "Fsurge: " << F_surge << " F_sway:" << F_sway << " F_vert:" << F_vert << " prop_force: " << prop_force << " tailRudder: " << in.tail_rudder << " tailElev: " << in.tail_elevator << endl;
        cout << " tail_x: " << tail_x << " tail_y: " << tail_y << " tail_z: " << tail_z << endl;
        cout << " vert_fore_force: " << vert_fore_force << " vert_aft_force: " << vert_aft_force << endl; 
        cout << " mutual_vert: " << mutual_vert << " differential_vert: " << differential_vert << endl;
        cout << " lat_fore_force: " << lat_fore_force << " lat_aft_force: " << lat_aft_force << endl; 
        cout << " mutual_lat: " << mutual_lat << " differential_lat: " << differential_lat << endl;
        cout << "T_hdg: " << T_hdg << " Td: " << Td << endl;
        cout << "dx:" << dxdt[XNDX] << " dy:" << dxdt[YNDX] << " dpsi:" << dxdt[HDGDOTNDX] << endl;
        loopCount = 0;
    }
}

// motor command callback
void on_motor_command(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const auv_nga_motor_command_t *mc, lcm::LCM *lcm) 
{
    in = *mc;
}


double rand_n(void) // generate normally distributed variable given uniformly distributed variable using the Box-Muller method
{
    double u,v;
    u = (double)rand()/(double)RAND_MAX;
    v = (double)rand()/(double)RAND_MAX;

    return pow(-2*log(u),0.5)*sin(2*M_PI*v);
}

// Calculate the path, this is where the magic happens
void calculate(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const heartbeat_t *heartbeat, lcm::LCM *lcm) 
{
    // call the solver
    //    integrate_n_steps(stepper, auv, state , 0.0 , 0.001 , 100 );
    integrate_const(stepper, auv, state , 0.0 , 0.1 , 0.01 ); // 1x speed simulation

    int64_t timeStamp = timestamp_now();

    //construct the nav message
    auv_acfr_nav_t nav;
    nav.utime = timeStamp;
    nav.x = state(XNDX);
    nav.y = state(YNDX);
    nav.depth = state(ZNDX);
    nav.roll = state(ROLLNDX);
    nav.pitch = state(PITCHNDX);
    nav.heading = state(HDGNDX);
    nav.vx = state(XDOTNDX);
    nav.vy = state(YDOTNDX);
    nav.vz = state(ZDOTNDX);
    nav.rollRate = state(ROLLDOTNDX);
    nav.pitchRate = state(PITCHDOTNDX);
    nav.headingRate = state(HDGDOTNDX);

    nav.altitude = WATER_DEPTH - nav.depth;

    double latitude_fix, longitude_fix;
    map_projection_sim->calc_geo_coords( nav.x + rand_n()*0.1, nav.y + rand_n()*0.1, latitude_fix, longitude_fix );
    nav.latitude = latitude_fix * M_PI/180;
    nav.longitude = longitude_fix * M_PI/180;

    if (timeStamp - last_print_time > 1*1e6) // 10 Hz
    {
        last_print_time = timeStamp;

        cout << "Truth: ";

        if(! fp.is_open() )
            fp.open("/tmp/log.txt",
        			ios::out|ios::app);
        for(int i=0; i<12; i++) {
            printf("%2.3f ", state(i));
            fp << state(i) << " ";
        }
        printf("%2.3f ", in.vert_fore);
        fp << in.vert_fore << " ";
        printf("%2.3f ", in.vert_aft);
        fp << in.vert_aft << " ";
        printf("%2.3f ", in.lat_fore);
        fp << in.lat_fore << " ";
        printf("%2.3f ", in.tail_thruster);
        fp << in.tail_thruster << " ";
        printf("%2.3f ", in.tail_rudder);
        fp << in.tail_rudder << " ";
        printf("%2.3f ", in.tail_elevator);
        fp << in.tail_elevator << " ";
        fp << "\n";
        fp.close();
        printf("\n");
        fflush(NULL);



        // publish the nav message
        //lcm->publish(vehicle_name+".ACFR_NAV", &nav);

    }
    lcm->publish(vehicle_name+".ACFR_NAV", &nav);
    // for simulating the sensors, acfr_nav_new should be publishing the ACFR_NAV

    //IMU
    //rotate gravity into local frame
    SMALL::Vector3D grav_b;

    SMALL::Rotation3D Cbn;
    Cbn.setRollPitchYawRad(state(3), state(4), state(5));

    grav_b = (Cbn.i() * grav); // look to local_planner.cpp implementation if this doesn't work

    //rotate earth rotation into the local frame
    SMALL::Vector3D earth_rot_b;
    earth_rot_b = (Cbn.i() * earth_rot);

    //compute acceleration at current time step
//    SMALL::Vector3D accel;
//    auv_accel(accel);

    //construct IMU message (biases to come later)
    senlcm::IMU_t imu;
    imu.utime = timeStamp;

    double dt = (timeStamp - last_obs_time)/1e6;

    if (dt > 0)
    {
        ba_x = ba_x + ( -1/TAU_A * ba_x + pow( (2*pow(BIAS_A,2)) / (TAU_A*dt) , 0.5 )*rand_n())*dt;
        ba_y = ba_y + ( -1/TAU_A * ba_y + pow( (2*pow(BIAS_A,2)) / (TAU_A*dt) , 0.5 )*rand_n())*dt;
        ba_z = ba_z + ( -1/TAU_A * ba_z + pow( (2*pow(BIAS_A,2)) / (TAU_A*dt) , 0.5 )*rand_n())*dt;
        bg_x = bg_x + ( -1/TAU_G * bg_x + pow( (2*pow(BIAS_G,2)) / (TAU_G*dt) , 0.5 )*rand_n())*dt;
        bg_y = bg_y + ( -1/TAU_G * bg_y + pow( (2*pow(BIAS_G,2)) / (TAU_G*dt) , 0.5 )*rand_n())*dt;
        bg_z = bg_z + ( -1/TAU_G * bg_z + pow( (2*pow(BIAS_G,2)) / (TAU_G*dt) , 0.5 )*rand_n())*dt;
    }

    imu.angRate[0] = state(9) + earth_rot_b[0] + bg_x + STD_G*rand_n();
    imu.angRate[1] = state(10) + earth_rot_b[1] + bg_y + STD_G*rand_n();
    imu.angRate[2] = state(11) + earth_rot_b[2] + bg_z + STD_G*rand_n();
    imu.accel[0] = accel[0] + grav_b[0] + ba_x + STD_A*rand_n();
    imu.accel[1] = accel[1] + grav_b[1] + ba_y + STD_A*rand_n();
    imu.accel[2] = accel[2] + grav_b[2] + ba_z + STD_A*rand_n();
    lcm->publish(vehicle_name+".IMU", &imu);

    //    if (timeStamp - last_print_time > 0.1*1e6) // 10 Hz
    //    {
    //        last_print_time = timeStamp;
    //        cout << "IMU: " << imu.angRate[0] << " " << imu.angRate[1] << " "<< imu.angRate[2] << " "<< imu.accel[0] << " "<< imu.accel[1] << " "<< imu.accel[2] << endl;
    //        cout << "accel: " << accel[0] << " " << accel[1] << " "<< accel[2] << endl;

    //    }


    //TCM compass
    if (timeStamp - last_tcm_time > 0.1*1e6) // 10 Hz
    {
        last_tcm_time = timeStamp;
        senlcm::tcm_t tcm;
        tcm.utime = timeStamp;
        tcm.heading = state(5) - MAG_VAR + rand_n()*0.5*M_PI/180;
        tcm.roll= state(3) + rand_n()*0.25*M_PI/180;
        tcm.pitch= state(4) + rand_n()*0.25*M_PI/180;
        tcm.temperature = 20;
        lcm->publish(vehicle_name+".TCM", &tcm);
    }

    // YSI depth
    if (timeStamp - last_ysi_time > 0.1*1e6) // 10 Hz
        //if(0)
    {
        last_ysi_time = timeStamp;
        senlcm::ysi_t ysi;
        ysi.utime = timeStamp;
        ysi.salinity = 35; // ppt
        ysi.temperature = 20;
        ysi.depth = state(2) + rand_n()*0.1;
        ysi.turbidity = 0;
        ysi.chlorophyl = 0;
        ysi.conductivity = 0;
        ysi.oxygen = 0;
        ysi.battery = 0;
        lcm->publish(vehicle_name+".YSI", &ysi);
    }

    // GPS
    if (timeStamp - last_gps_time > 1*1e6) // 1 Hz
    {
        last_gps_time = timeStamp;
        if (nav.depth < 2) // 1m depth is where GPS cuts out, but simulation starts at 1m depth, so make it 2
        {
            SMALL::Vector4D nuLinear;
            nuLinear = nav.vx, nav.vy, nav.vz, 0.0;
            SMALL::Pose3D auvPose;
            auvPose.setPosition(nav.x, nav.y, nav.depth);
            auvPose.setRollPitchYawRad(nav.roll, nav.pitch, nav.heading);
            SMALL::Vector3D etaDotLin;
            etaDotLin = (auvPose.get3x4TransformationMatrix() * nuLinear);

            senlcm::gpsd3_t * gpsd3;
            gpsd3 = new senlcm::gpsd3_t;
            std::vector< int16_t > gused;
            std::vector< int16_t > gPRN;
            std::vector< int16_t > gelevation;
            std::vector< int16_t > gazimuth;
            std::vector< int16_t > gss;

            gpsd3->online = 0;
            gpsd3->fix.ept = 0;
            gpsd3->fix.epy = 0;
            gpsd3->fix.epx = 0;
            gpsd3->fix.epv = 0;
            gpsd3->fix.epd = 0;
            gpsd3->fix.eps = 0;
            gpsd3->fix.climb = 0;
            gpsd3->fix.epc = 0;
            gpsd3->geoidal_separation = 0;
            gpsd3->satellites_used = GPS_CHANNELS;
            for (int i=0; i<gpsd3->satellites_used; i++)
                gused.push_back(0);

            gpsd3->used = gused;
            gpsd3->dop.pdop = 0;
            gpsd3->dop.hdop = 0;
            gpsd3->dop.tdop = 0;
            gpsd3->dop.gdop = 0;
            gpsd3->dop.xdop = 0;
            gpsd3->dop.ydop = 0;
            gpsd3->epe    = 0;
            gpsd3->skyview_utime = 0;
            gpsd3->satellites_visible = GPS_CHANNELS;
            for (int i=0; i<gpsd3->satellites_visible; i++) {
                gPRN.push_back(0);
                gelevation.push_back(0);
                gazimuth.push_back(0);
                gss.push_back(0);
            }
            gpsd3->PRN = gPRN;
            gpsd3->elevation = gelevation;
            gpsd3->azimuth = gazimuth;
            gpsd3->ss = gss;
            gpsd3->dev.path = strdup("");
            gpsd3->dev.flags = 0;
            gpsd3->dev.driver = strdup("");
            gpsd3->dev.subtype = strdup("");
            gpsd3->dev.activated = 0;
            gpsd3->dev.baudrate = 0;
            gpsd3->dev.stopbits = 0;
            gpsd3->dev.cycle = 0;
            gpsd3->dev.mincycle = 0;
            gpsd3->dev.driver_mode = 0;
            gpsd3->fix.track = atan2( etaDotLin[1], etaDotLin[0] ) * 180/M_PI;
            gpsd3->fix.speed = pow(pow(etaDotLin[0],2) + pow(etaDotLin[1],2),0.5);
            double latitude_fix, longitude_fix;
            map_projection_sim->calc_geo_coords( nav.x + rand_n()*2, nav.y + rand_n()*2, latitude_fix, longitude_fix );
            gpsd3->fix.latitude = latitude_fix * M_PI/180;
            gpsd3->fix.longitude = longitude_fix * M_PI/180;
            gpsd3->fix.altitude = -nav.depth;
            gpsd3->fix.utime = timeStamp;
            gpsd3->utime = timeStamp;
            gpsd3->fix.mode = 3;
            gpsd3->status = 1;
            gpsd3->tag = strdup("");
            lcm->publish(vehicle_name+".GPSD_CLIENT", gpsd3);
            delete gpsd3;
        }
    }

    // DVL
    if (timeStamp - last_dvl_time > 0.3*1e6) // once every 0.3 seconds
    {
        last_dvl_time = timeStamp;
        senlcm::rdi_pd5_t rdi;

        rdi.utime = timeStamp;
        rdi.pd4.xducer_head_temp = 20;
        rdi.pd4.altitude = nav.altitude;
        rdi.pd4.range[0] = nav.altitude;
        rdi.pd4.range[1] = nav.altitude;
        rdi.pd4.range[2] = nav.altitude;
        rdi.pd4.range[3] = nav.altitude;
        rdi.pd4.btv[0] = nav.vx + rand_n()*0.003;
        rdi.pd4.btv[1] = nav.vy + rand_n()*0.003;
        rdi.pd4.btv[2] = nav.vz + rand_n()*0.003;
        rdi.pitch = nav.pitch + rand_n()*0.25*M_PI/180;
        rdi.roll = nav.roll + rand_n()*0.25*M_PI/180;
        rdi.heading = nav.heading  - MAG_VAR + rand_n()*2*M_PI/180;

        if (nav.altitude < 50)
            rdi.pd4.btv_status = 0;
        else
            rdi.pd4.btv_status = 1; // beyond dvl bl range

        rdi.pd4.speed_of_sound = 1521.495;
        lcm->publish(vehicle_name+".RDI", &rdi);
    }

    last_obs_time = timeStamp;

}

void on_nav_store(const lcm::ReceiveBuffer* rbuf, const std::string& channel, const auv_acfr_nav_t *nav, lcm::LCM *lcm) {
    cout << "Nav: ";

    double nav_state[13];

    nav_state[0] = nav->x;
    nav_state[1] = nav->y;
    nav_state[2] = nav->depth;
    nav_state[3] = nav->roll;
    nav_state[4] = nav->pitch;
    nav_state[5] = nav->heading;
    nav_state[6] = nav->vx;
    nav_state[7] = nav->vy;
    nav_state[8] = nav->vz;
    nav_state[9] = nav->rollRate;
    nav_state[10] = nav->pitchRate;
    nav_state[11] = nav->headingRate;

    nav_state[12] = nav->altitude;

    if( !fp_nav.is_open() )
        fp_nav.open( "/tmp/log_nav.txt",
    			ios::out | ios::app);
    for(int i=0; i<13; i++) {
        printf("%2.3f ", nav_state[i]);
        fp_nav << nav_state[i] << " ";
    }
    fp_nav << "\n";
    fp_nav.close();
    printf("\n");
    fflush(NULL);

}

void print_help (int exval, char **argv)
{                                                                               
    printf("Usage:%s [-h] [-n VEHICLE_NAME]\n\n", argv[0]);                     
    
    printf("  -h                               print this help and exit\n");    
    printf("  -n VEHICLE_NAME                  set the vehicle_name\n");        
    exit (exval);                                                               
}                                                                               
                                                                                
void                                                                            
parse_args (int argc, char **argv)                                              
{                                                                            
    int opt;                                                                    
                                                                                
    while ((opt = getopt (argc, argv, "hn:")) != -1)                            
    {                                                                           
        switch(opt)                                                             
        {                                                                       
            case 'h':                                                               
                print_help (0, argv);                                               
                break;                                                              
            case 'n':                                                               
                vehicle_name = (char*)optarg;                                       
                break;                                                              
         }                                                                      
    }                                                                           
}
        
int main_exit;
void signal_handler(int sig)
{
    main_exit = 1;
}

int main(int argc, char **argv)
{
    cout << "Starting sim..." << endl;
    parse_args(argc, argv);

    // install the signal handler
    main_exit = 0;
    signal(SIGINT, signal_handler);

    lcm::LCM lcm;

    //srand(time(NULL));
    srand(1234); // seeding the same way every time to allow filter comparisons

    BotParam *param = NULL;
    param = bot_param_new_from_server (lcm.getUnderlyingLCM(), 1);
    if(param == NULL)
        return 0;

    char rootkey[64];
    char key[128];
    sprintf (rootkey, "nav.acfr-nav-new");

    double latitude_sim, longitude_sim;
    sprintf(key, "%s.latitude", rootkey);
    latitude_sim = bot_param_get_double_or_fail(param, key);
    sprintf(key, "%s.longitude", rootkey);
    longitude_sim = bot_param_get_double_or_fail(param, key);

    map_projection_sim = new Local_WGS84_TM_Projection(latitude_sim, longitude_sim);

    //Earth rotation vector in the navigation frame
    earth_rot = cos(latitude_sim*M_PI/180)*7.292115e-5,0,-sin(latitude_sim*M_PI/180)*7.292115e-5;

    //Set gravity
    grav = 0.0, 0.0, -9.81;

    int64_t timeStamp = timestamp_now();
    last_dvl_time = timeStamp;
    last_gps_time = timeStamp;
    last_ysi_time = timeStamp;
    last_tcm_time = timeStamp;
    last_print_time = timeStamp;
    last_obs_time = timeStamp;

    //initialise drifting biases
    ba_x = BIAS_A*rand_n();
    ba_y = BIAS_A*rand_n();
    ba_z = BIAS_A*rand_n();
    bg_x = BIAS_G*rand_n();
    bg_y = BIAS_G*rand_n();
    bg_z = BIAS_G*rand_n();


    lcm.subscribeFunction(vehicle_name+".NEXTGEN_MOTOR", on_motor_command, &lcm);
    lcm.subscribeFunction("HEARTBEAT_10HZ", calculate, &lcm);
    //lcm.subscribeFunction("HEARTBEAT_100HZ", calculate, &lcm); // needs to happen at 100 Hz due to IMU
    //lcm.subscribeFunction(vehicle_name+".ACFR_NAV", on_nav_store, &lcm);

    //populate_inv_inertia();

    // Interial matrices
    longM = m - Xudot, 			-Xwdot, 			m * zG - Xqdot,
            -Xwdot, 			m - Zwdot, 			-m * xG - Zqdot,
            m * zG - Xqdot, 	-m * xG - Zqdot, 	Iy - Mqdot;

    latM = 	m - Yvdot,			-m * zG - Ypdot,	m * xG - Yrdot,
            -m * zG - Ypdot,	Ix - Kpdot,			-Izx - Krdot,
            m * xG - Yrdot,		-Izx - Krdot,		Iz - Nrdot;

    // initial conditions
    state(XNDX) = -10;
    state(YNDX) = -10;
    state(ZNDX) = 1.9;  //Z = 1;
    state(ROLLNDX) = 0;
    state(PITCHNDX) = 0;
    state(HDGNDX) = 0;
    state(XDOTNDX) = 0;
    state(YDOTNDX) = 0;
    state(ZDOTNDX) = 0;
    state(ROLLDOTNDX) = 0;
    state(PITCHDOTNDX) = 0;
    state(HDGDOTNDX) = 0;

    in.vert_fore = 0;
    in.vert_aft = 0;
    in.lat_fore = 0;
    in.lat_aft = 0;
    in.tail_thruster = 0;
    in.tail_rudder = 0;
    in.tail_elevator = 0;

    fp_nav.open( "/tmp/log_nav.txt", ios::out);
    fp.open("/tmp/log.txt", ios::out);

    int fd = lcm.getFileno();
    fd_set rfds;
    while(!main_exit)
    {
        FD_ZERO (&rfds);
        FD_SET (fd, &rfds);
        struct timeval timeout;
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        int ret = select (fd + 1, &rfds, NULL, NULL, &timeout);
        if(ret > 0)
            lcm.handle();
    }
    delete map_projection_sim;
    if( fp.is_open())
    	fp.close();
    if( fp_nav.is_open() )
    	fp_nav.close();
    return 0;
}



