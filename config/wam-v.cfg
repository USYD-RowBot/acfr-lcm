sensors {
#    gpsd3-client {
#        gsd {
#            io = "none";
#            channel = "GPSD_CLIENT";
#        }
#        gpsddev="/dev/ttyS9";
#    }
        
    	gsd {
            io = "serial";
            #device = "/dev/ttyUSB5";
            device = "/dev/tcm";
            baud = 38400;
            parity = "8N1";
            channel = "TCM";
        }
    

    os-compass {
    	gsd {
            io = "serial";
            #device = "/dev/ttyUSB6";
            device = "/dev/os-compass";
            baud = 19200;
            parity = "8N1";
            channel = "OS_COMPASS";
        }
    }

#    rdi {
#        gsd {
#            io = "serial";
#            device = "/dev/ttyS6";
#            baud   = 19200;
#            parity = "8N1";
#            channel = "RDI";
#        }
#	mode = "PD5";
#	pd5_count_max = 5;
#	pd0_count_max = 0;
#	range = 50; # max range for dvl in (m)
#
#    } #rdi
    
#    os-power-system
#    {
#        io = "serial";
#        num_devs = 1;
#        serial_devs = ["/dev/ttyS11"];
#        baud = 19200;
#        parity = "8N1";
#    }

#    evologics-modem
#    {
#        ip = "172.16.154.124"; # SN 1834/17#209/4 on serial port server
#        port = "1001";
#        ping_period = -1;
#        ping_timeout = 20;
#        gain = 0;
#        source_level = 1;
#        auto_gain = "false";
#        targets = [1];
#        target_names = ["HOLT"];
#        lcm_pbm = ["AUVSTAT.*"];
#
#        vehicle_name = "holt";
#        logging_level = 2;
#	sound_speed = 1500;
#    }

} #sensors


nav {
    
    acfr-nav-new
    {
        slam_config = "/home/auv/git/acfr_lcm/config/slam_wam-v.cfg";
        attitude_source = "TCM";
        depth_source = "OS_COMPASS";
    }
}

acfr {
#    cam-trigger {
#        #device = "/dev/ttyUSB0";
#        device = "/dev/ttyS5";
#        baud = 115200;
#        parity = "8N1";
#        pulseWidthUs = 7000;
#        strobeDelayUs = 0;
#        frequency = 2.5;
#    }
#
    
#    rc
#    {
#        motor_device = "/dev/ttyS6";
#        motor_baud = 9600;
#        motor_parity = "8N1";
#        
#        fins_device = "/dev/ttyS7";
#        fins_baud = 9600;
#        fins_parity = "8N1";
#        
#        control_port = "9001";
#        motor_tcp_port = "9002";
#        fins_tcp_port = "9003";
#    }
#    
#    iver-rc
#    {
#        control_port = "9001";
#    }

    auv-control
    {
        velocity
        {
            kp = 1500;
            ki = 50;
            kd = 0.0;
           sat = 1500;
           # sat = 0;
        }
        
	# TODO: we should change this to only use integral.
	# We cannot compensate for the dynamic roll and 
	#    should aim to just have an integral instead.
        roll
        {
            kp = 0.0; #0.5;
            ki = 0.0; #0.0;
            kd = 0.0; #0.0;
            sat = 0.0; #0.1;
        }
        # Control parameters for depth control (sets pitch setpoint) 
        depth
        {
            kp = 0.5;
            ki = 0.00;
            kd = 0.15;
            sat = 0.3;
        }
       
        # Control parameters for pitch control (sets pitch planes) 
        pitch
        {
            # SBW Disabled pitch control at Lizard Island for surface only operation
            kp = -1.35;
            ki = -0.05;
            kd = 0.0;
            sat = 0.4;
            #kp = 0.0;
            #ki = 0.0;
            #kd = 0.0;
            #sat = 0.3;
        }

        pitch_r
        {
        
            kp = 0.0;
            ki = 0.0;
            kd = 0.0;
            sat = 0.6;
        }

        altitude
        {
            kp = 1.0;
            ki = 0.0;
            kd = 0.0;
            sat = 10.0;
        }

        heading
        {
            kp = 2.0;
            ki = 0.000;
            kd = 0.00;
            sat = 0.6;
        }

        pitch_max = 0.34;
        plane_rudder_max = 0.4;
        main_rpm_max = 1500;
        roll_offset_max = 0.2;

    }
    
    local-planner
    {

        turning_radius = 10; #5;
        minimum_altitude = 1.0;
        maximum_pitch = 0.4;

        velocity_change_distance = 3;
        default_leg_velocity = 1;

        look_ahead_velocity_scale = 0;        
        max_dist_from_line = 1;
        max_angle_from_line = 0.4;

        max_angle = 220;
        max_angle_waypoint_change = 20;
        radius_increase = 1;
        
        forward_bound = 4.0;
        side_bound = 4.0;
        drop_dist = 4; #5.0;
        drop_angle = 25; #57;
        dist_to_dest_bound = 4.0;
        waypoint_timeout = 20;
        
        replan_interval = 1000;
	      
    }
        
    health
    {
        # operatations bounding box
        #min_x = -900;
        #max_x = 3000;
        #min_y = -900;
        #max_y = +900;
        max_depth = 15.0;
        min_alt = 0.05;
        max_pitch = 0.75;
        vehicle_name = "WAM-V";
    }
}

torqeedo
{    
    port-motor
    {
        channel_control = "PORT_MOTOR_CONTROL";
        channel_status = "PORT_MOTOR_STATUS";
        io = "serial";
        serial_dev = "/dev/ttyUSB0";
        baud = 19200;
        parity = "8N1";
        verbose = "false";
    }

    starboard-motor
    {
        channel_control = "STARBOARD_MOTOR_CONTROL";
        channel_status = "STARBOARD_MOTOR_STATUS";
        io = "serial";
        serial_dev = "/dev/ttyUSB1";
        baud = 19200;
        parity = "8N1";
        verbose = "true";
    }
}


#vimba {
#    cam2 {
#        uid = "02-2140A-17854";
#        mac = "000F314D0E77";
#        channel = "PROSILICA_AC16";
#        publish = "false";
#        scale = 1;
#        features {
#            PixelFormat = "BayerRG12";
#            
#            AcquisitionFrameCount = 1;
#            AcquisitionMode = "Continuous";
#            AcquisitionFrameRateAbs = 1.0;
#            
#            TriggerActivation = "RisingEdge";
#            TriggerSource = "Line1"; #"FixedRate";
#            TriggerSelector = "FrameStart";
#            TriggerDelayAbs = 2000.0;
#            TriggerMode = "On";
#            TriggerOverlap = "Off";
#
#            ExposureAuto = "Continuous";
#            ExposureAutoAlg = "Mean"; 
#            ExposureAutoMax = "6000"; 
#            ExposureAutoMin = 43;
#            ExposureAutoTarget = 10;
#            
#            GainAuto = "Off";
#            GainAutoMax = 30;
#            GainAutoMin = 0;
#            GainRaw = 0;
#           StreamBytesPerSecond = "45000000"; 
#        }
#    }
#    
#    cam1 {
#        uid = "02-2141A-16910";
#        mac = "000F314D0E78";
#        channel = "PROSILICA_FC16";
#        publish = "true";
#        scale = 1;
#        features {
#            
#            PixelFormat = "BayerRG12";
#            
#            AcquisitionFrameCount = 1;
#            AcquisitionMode = "Continuous";
#            AcquisitionFrameRateAbs = 1.0;
#            
#            TriggerActivation = "RisingEdge";
#            TriggerSource = "Line1";
#            TriggerSelector = "FrameStart";
#            TriggerDelayAbs = 2000.0;
#            TriggerMode = "On";
#            TriggerOverlap = "Off";
#
#            ExposureAuto = "Continuous";
#            ExposureAutoAlg = "Mean"; 
#            ExposureAutoMax = 6000; 
#            ExposureAutoMin = 43;
#            ExposureAutoTarget = 10;
#            
#
#            GainAuto = "Off";
#            GainAutoMax = 27;
#            GainAutoMin = 0;
#            GainRaw = 8;
#	    StreamBytesPerSecond = "45000000";
#            
#        }
#    }
#}


site {
    salinity = 0;
}
